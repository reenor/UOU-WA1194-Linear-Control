<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

	
<!-- Mirrored from ctms.engin.umich.edu/CTMS/index.php?example=InvertedPendulum&section=ControlDigital by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 19 Jun 2014 21:05:29 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>

		<script type="text/javascript" src="jquery.js"></script>
					
		<link rel='stylesheet' type='text/css' href='style.css' />
		<script type="text/javascript">
	
			var example = "InvertedPendulum"; 
			var section = "ControlDigital"; 
			var aux = ""; 
			var effects = Boolean(1); 
			var tips = Boolean(1); 
			$.fx.off = !effects;
			
			$(document).keydown(function(e){
				if (!$("#search_field").is(":focus")){
					if (e.keyCode == 39) { 
						window.location = "indexffaa.html?example=InvertedPendulum&amp;section=SimulinkModeling";
					}
					if (e.keyCode == 37) { 
						window.history.back()
					}
				}
			});		
			
		</script>
			
		<meta http-equiv="Content-Type" Content="text/html; charset=utf-8" />
		<meta http-equiv="PRAGMA" Content="NO-CACHE" />
		
		<title>Control Tutorials for MATLAB and Simulink - Inverted Pendulum: Digital Controller Design</title>
			
	</head>

	<body>
	
		
		<div id="container">
		
			<form id="search_form"><input id="search_field" type="text" name="q" placeholder="Search Control Tutorials"/></form>
			<form class="option_form" method="post" onclick="submit()"><div>Effects</div><input type="hidden" name="effects" value="0"/><input type="checkbox" name="effects" value="1" checked='true' /></form>
			<form class="option_form" method="post" onclick="submit()"><div>Tips</div><input type="hidden" name="tips" value="0"/><input type="checkbox" name="tips" value="1" checked='true' /></form>	
				
			<div style="clear:both"></div>
		
			<div id="header">
		
				

				
				
				<div id="menu_container">
				
					<ul class="menu">
						<li class="heading" id="Tips"><a href="index80e7.html?aux=Extras_Tips">TIPS</a></li>
						<div class="collapse"><div class="expand">
						</div></div>
					</ul>
				
					<ul class="menu">
						<li class="heading" id="About"><a>ABOUT</a></li>
						<div class="collapse"><div class="expand">
							<li class="item" id="About_Tutorials"><a href="index64fe.html?aux=About_Tutorials">Tutorials</a></li>
							<li class="item" id="About_Contact"><a href="mailto:ControlTutorialsMatlabSimulink@gmail.com">Contact</a></li>
						</div></div>
					</ul>
					
					<ul class="menu">
						<li class="heading" id="Basics"><a>BASICS</a></li>
						<div class="collapse"><div class="expand">
							<li class="item" id="Basics_Matlab"><a href="index87b6.html?aux=Basics_Matlab">MATLAB</a></li>
							<li class="item" id="Basics_Simulink"><a href="indexe9ea.html?aux=Basics_Simulink">Simulink</a></li>
						</div></div>
					</ul>
					
					<ul class="menu">
						<li class="heading" id="Index"><a>INDEX</a></li>
						<div class="collapse"><div class="expand">
							<li class="item" id="Index_Tutorials"><a href="index5e52.html?aux=Index_Tutorials">Tutorials</a></li>
							<li class="item" id="Index_Commands"><a href="index111e.html?aux=Index_Commands">Commands</a></li>
							<li class="item" id="Index_Animations"><a href="indexc3c5.html?aux=Index_Animations">Animations</a></li>
							<li class="item" id="Index_Extras"><a href="indexb290.html?aux=Index_Extras">Extras</a></li>
						</div></div>
					</ul>
									
					<ul class="menu">
						<li class="heading" id="Next"><a href="indexffaa.html?example=InvertedPendulum&amp;section=SimulinkModeling">NEXT&nbsp;&#x25BA;</a></li>
						<div class="collapse"><div class="expand">
						</div></div>
					</ul>
											
				</div>

			</div>
			
			<div id="body_container">
			
				<div id="gradient_container"></div>
			
				<div id="top">
				
					<a href="index1304.html?aux=Home"><img id="CTMS_logo" src="Images/CTMS_logo.png"></a>
				
					<ul class="example">
					
						<li class="item" id="Introduction"><a href="index4e79.html?example=Introduction&amp;section=ControlDigital"><img class="icon" src="Images/Introduction_Icon.png"><div class="tab">INTRODUCTION</div></a></li>
						<li class="item" id="CruiseControl"><a href="index6e12.html?example=CruiseControl&amp;section=ControlDigital"><img class="icon" src="Images/CruiseControl_Icon.png"><div class="tab">CRUISE&nbsp;CONTROL</div></a></li>
						<li class="item" id="MotorSpeed"><a href="indexf267.html?example=MotorSpeed&amp;section=ControlDigital"><img class="icon" src="Images/MotorSpeed_Icon.png"><div class="tab">MOTOR&nbsp;SPEED</div></a></li>
						<li class="item" id="MotorPosition"><a href="index7d62.html?example=MotorPosition&amp;section=ControlDigital"><img class="icon" src="Images/MotorPosition_Icon.png"><div class="tab">MOTOR&nbsp;POSITION</div></a></li>
						<li class="item" id="Suspension"><a href="index3cf8.html?example=Suspension&amp;section=ControlDigital"><img class="icon" src="Images/Suspension_Icon.png"><div class="tab">SUSPENSION</div></a></li>
						<li class="item" id="InvertedPendulum"><a href="index5759.html?example=InvertedPendulum&amp;section=ControlDigital"><img class="icon" src="Images/InvertedPendulum_Icon.png"><div class="tab">INVERTED&nbsp;PENDULUM</div></a></li>
						<li class="item" id="AircraftPitch"><a href="index3b26.html?example=AircraftPitch&amp;section=ControlDigital"><img class="icon" src="Images/AircraftPitch_Icon.png"><div class="tab">AIRCRAFT&nbsp;PITCH</div></a></li>
						<li class="item" id="BallBeam"><a href="index447e.html?example=BallBeam&amp;section=ControlDigital"><img class="icon" src="Images/BallBeam_Icon.png"><div class="tab">BALL&nbsp;&amp;&nbsp;BEAM</div></a></li>
					
					</ul> 
		
				</div>
				
				<div id="content_container">
					<div class="content">
   <div class="content_fx">
      <h1>Inverted Pendulum: Digital Controller Design</h1>
      <!--introduction-->
      <p>Key MATLAB commands used in this tutorial are: <a href="http://www.mathworks.com/help/toolbox/control/ref/ss.html"><tt>ss</tt></a> , <a href="http://www.mathworks.com/help/toolbox/control/ref/c2d.html"><tt>c2d</tt></a> , <a href="http://www.mathworks.com/help/toolbox/control/ref/ctrb.html"><tt>ctrb</tt></a> , <a href="http://www.mathworks.com/help/toolbox/control/ref/obsv.html"><tt>obsv</tt></a> , <a href="http://www.mathworks.com/help/toolbox/control/ref/dlqr.html"><tt>dlqr</tt></a> , <a href="http://www.mathworks.com/help/toolbox/control/ref/lsim.html"><tt>lsim</tt></a> , <a href="http://www.mathworks.com/help/toolbox/rf/plotyy.html"><tt>plotyy</tt></a> , <a href="http://www.mathworks.com/help/techdoc/ref/eig.html"><tt>eig</tt></a> , <a href="http://www.mathworks.com/help/toolbox/control/ref/place.html"><tt>place</tt></a></p>
      <!--/introduction-->
      <h2>Contents</h2>
      <div>
         <ul>
            <li><a href="#4">Discrete state-space</a></li>
            <li><a href="#6">Controllability and observability</a></li>
            <li><a href="#10">Control design via pole placement</a></li>
            <li><a href="#14">Precompensator design</a></li>
            <li><a href="#16">Observer design</a></li>
         </ul>
      </div>
      <p>In this digital control version of the inverted pendulum problem, we will use the state-space method to design the digital
         controller. If you refer to the <a href="indexdeb1.html?example=InvertedPendulum&amp;section=SystemModeling">Inverted Pendulum: System Modeling</a> page, the linearized state-space equations were derived as:
      </p>
      <p><span class="eqn_num">(1)</span><img class="display_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq60747.png" alt="$$&#xA;\left[{\begin{array}{c}&#xA;  \dot{x}\\ \ddot{x}\\ \dot{\phi}\\ \ddot{\phi}&#xA;\end{array}}\right] =&#xA;\left[{\begin{array}{cccc}&#xA;  0&amp;1&amp;0&amp;0\\&#xA;  0&amp;\frac{-(I+ml^2)b}{I(M+m)+Mml^2}&amp;\frac{m^2gl^2}{I(M+m)+Mml^2}&amp;0\\&#xA;  0&amp;0&amp;0&amp;1\\&#xA;  0&amp;\frac{-mlb}{I(M+m)+Mml^2}&amp;\frac{mgl(M+m)}{I(M+m)+Mml^2}&amp;0&#xA;\end{array}}\right]&#xA;\left[{\begin{array}{c}&#xA;  x\\ \dot{x}\\ \phi\\ \dot{\phi}&#xA;\end{array}}\right]+&#xA;\left[{\begin{array}{c}0\\&#xA;  \frac{I+ml^2}{I(M+m)+Mml^2}\\&#xA;  0 \\&#xA;  \frac{ml}{I(M+m)+Mml^2}&#xA;\end{array}}\right]u$$"></p>
      <p><span class="eqn_num">(2)</span><img class="display_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq01518.png" alt="$${\bf y} =&#xA;\left[{\begin{array}{cccc}&#xA;  1&amp;0&amp;0&amp;0\\0&amp;0&amp;1&amp;0&#xA;\end{array}}\right]&#xA;\left[{\begin{array}{c}&#xA;  x\\ \dot{x}\\ \phi\\ \dot{\phi}&#xA;\end{array}}\right]+&#xA;\left[{\begin{array}{c}&#xA;  0\\0&#xA;\end{array}}\right]u$$"></p>
      <p>where:</p><pre>(M)       mass of the cart                         0.5 kg</pre><pre>(m)       mass of the pendulum                     0.2 kg</pre><pre>(b)       coefficient of friction for cart         0.1 N/m/sec</pre><pre>(l)       length to pendulum center of mass        0.3 m</pre><pre>(I)       mass moment of inertia of the pendulum   0.006 kg.m^2</pre><pre>(F)       force applied to the cart</pre><pre>(x)       cart position coordinate</pre><pre>(theta)   pendulum angle from vertical (down)</pre><p>For this problem the outputs are the cart's displacement (<img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq43551.png" alt="$x$"> in meters) and the pendulum angle (<img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq26509.png" alt="$\phi$"> in radians) where <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq26509.png" alt="$\phi$"> represents the deviation of the pedulum's position from equilibrium, that is, <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq49435.png" alt="$\theta$"> = <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq11731.png" alt="$\pi$"> + <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq26509.png" alt="$\phi$">.
      </p>
      <p>The design criteria for this system for a 0.2-m step in desired cart position <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq43551.png" alt="$x$"> are as follows:
      </p>
      <div>
         <ul>
            <li>Settling time for <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq43551.png" alt="$x$"> and <i>theta</i> of less than 5 seconds
            </li>
            <li>Rise time for <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq43551.png" alt="$x$"> of less than 0.5 seconds
            </li>
            <li>Pendulum angle <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq49435.png" alt="$\theta$"> never more than 20 degrees (0.35 radians) from the vertical
            </li>
            <li>Steady-state error of less than 2% for <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq43551.png" alt="$x$"> and <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq49435.png" alt="$\theta$"></li>
         </ul>
      </div>
      <h2>Discrete state-space<a name="4"></a></h2>
      <p>Our first step in designing a digital controller is to convert the above continuous state-space equations to a discrete form.
         We will accomplish this employing the MATLAB function <tt>c2d</tt>. This function requires that we specify three arguments: a continuous system model, the sampling time (<tt>Ts</tt> in sec/sample), and the <tt>'method'</tt>. You should already be familiar with how to construct a state-space system from <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq53374.png" alt="$\mathbf{A}$">, <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq68788.png" alt="$\mathbf{B}$">, <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq50346.png" alt="$\mathbf{C}$">, and <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq76245.png" alt="$\mathbf{D}$"> matrices.
      </p>
      <p>In choosing a sample time, note that it is desired that the sampling frequency be fast compared to the dynamics of the system.
         One measure of a system's "speed" is its closed-loop bandwidth. A good rule of thumb is that the sampling time be smaller
         than 1/30th of the closed-loop bandwidth frequency which can be determined from the closed-loop Bode plot.
      </p>
      <p>Assuming that the closed-loop bandwidth frequencies are around 1 rad/sec for both the cart and the pendulum, let the sampling
         time be 1/100 sec/sample. The discretization method we will use is the <b>zero-order hold</b> (<tt>'zoh'</tt>). For further details, refer to the <a href="index4e79.html?example=Introduction&amp;section=ControlDigital">Introduction: Digital Controller Design</a> page. Now we are ready to use <tt>c2d</tt> function. Enter the following commands into an <a href="indexd754.html?aux=Extras_Mfile">m-file</a>. Running this m-file in the MATLAB command window gives you the following four matrices representing the discrete time state-space
         model.
      </p><pre class="codeinput">M = 0.5;
m = 0.2;
b = 0.1;
I = 0.006;
g = 9.8;
l = 0.3;

p = I*(M+m)+M*m*l^2; <span class="comment">%denominator for the A and B matrices</span>

A = [0      1              0           0;
     0 -(I+m*l^2)*b/p  (m^2*g*l^2)/p   0;
     0      0              0           1;
     0 -(m*l*b)/p       m*g*l*(M+m)/p  0];
B = [     0;
     (I+m*l^2)/p;
          0;
        m*l/p];
C = [1 0 0 0;
     0 0 1 0];
D = [0;
     0];

states = {<span class="string">'x'</span> <span class="string">'x_dot'</span> <span class="string">'phi'</span> <span class="string">'phi_dot'</span>};
inputs = {<span class="string">'u'</span>};
outputs = {<span class="string">'x'</span>; <span class="string">'phi'</span>};

sys_ss = ss(A,B,C,D,<span class="string">'statename'</span>,states,<span class="string">'inputname'</span>,inputs,<span class="string">'outputname'</span>,outputs);

Ts = 1/100;

sys_d = c2d(sys_ss,Ts,<span class="string">'zoh'</span>)
</pre><pre class="codeoutput">
sys_d =
 
  a = 
                     x       x_dot         phi     phi_dot
   x                 1    0.009991   0.0001336   4.453e-07
   x_dot             0      0.9982     0.02672   0.0001336
   phi               0  -2.272e-05       1.002     0.01001
   phi_dot           0   -0.004544      0.3119       1.002
 
  b = 
                    u
   x        9.086e-05
   x_dot      0.01817
   phi      0.0002272
   phi_dot    0.04544
 
  c = 
              x    x_dot      phi  phi_dot
   x          1        0        0        0
   phi        0        0        1        0
 
  d = 
        u
   x    0
   phi  0
 
Sample time: 0.01 seconds
Discrete-time state-space model.

</pre><p>Now we have obtained the discrete state-space model of the form:</p>
      <p><span class="eqn_num">(3)</span><img class="display_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq14148.png" alt="$$\left[{\begin{array}{c}&#xA;x(k+1)\\ \dot{x}(k+1)\\ \*\phi(k+1)\\ *\dot{\phi}(k+1)&#xA;\end{array}}\right]=&#xA;\left[{\begin{array}{cccc}&#xA;1&amp;0.01&amp;0.0001&amp;0\\&#xA;0&amp;0.9982&amp;0.0267&amp;0.0001\\&#xA;0&amp;0&amp;1.0016&amp;0.01\\&#xA;0&amp;-0.0045&amp;0.3119&amp;1.0016&#xA;\end{array}}\right]&#xA;\left[{\begin{array}{c}&#xA;x(k)\\ \dot{x}(k)\\ *\phi(k)\\ *\dot{\phi}(k)&#xA;\end{array}}\right]&#xA;+&#xA;\left[{\begin{array}{c}&#xA;0.0001\\ 0.0182\\ 0.0002\\ 0.0454&#xA;\end{array}}\right]u(k)$$"></p>
      <p><span class="eqn_num">(4)</span><img class="display_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq01914.png" alt="$${\bf y}(k) = \left[{\begin{array}{cccc}1&amp;0&amp;0&amp;0\\0&amp;0&amp;1&amp;0\end{array}}\right]&#xA;\left[{\begin{array}{c}&#xA;x(k)\\ \dot{x}(k)\\ *\phi(k)\\ *\dot{\phi}(k)&#xA;\end{array}}\right]&#xA;+\left[{\begin{array}{c}0\\0\end{array}}\right]u(k)$$"></p>
      <h2>Controllability and observability<a name="6"></a></h2>
      <p>The next step is to check the controllability and the observability of the system. For the system to be completely state controllable,
         the controllability matrix
      </p>
      <p><span class="eqn_num">(5)</span><img class="display_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq71380.png" alt="$$C =&#xA;\left[{\begin{array}{ccccc}&#xA;B &amp; AB &amp; A^2B &amp; \cdots &amp; A^{n-1}B&#xA;\end{array}}\right]$$"></p>
      <p>must have the <b>rank of n</b>. The rank of the matrix is the number of independent rows (or columns). In the same token, for the system to be completely
         state observable, the observability matrix
      </p>
      <p><span class="eqn_num">(6)</span><img class="display_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq47539.png" alt="$$O =&#xA;\left[{\begin{array}{c}&#xA;C \\ CA \\ \vdots \\ CA^{n-1}&#xA;\end{array}}\right]$$"></p>
      <p>must also have the <b>rank of n</b>. These tests for controllability and observability are identical to the situation of continuous control except that now the
         state space model is discrete.
      </p>
      <p>Since the number of state variables in our system is 4, the rank of both matrices must be 4. The function <tt>rank</tt> can give you the rank of each matrix. Adding the following commands to your m-file and running in the MATLAB command window
         will generate the results shown below.
      </p><pre class="codeinput">co = ctrb(sys_d);
ob = obsv(sys_d);

controllability = rank(co)
observability = rank(ob)
</pre><pre class="codeoutput">controllability =
     4
observability =
     4
</pre><p>This proves that our discrete system is both completely state controllable and completely state observable.</p>
      <h2>Control design via pole placement<a name="10"></a></h2>
      <p>The schematic of a full-state feedback control system is shown below.</p>
      <p><img class="figure"vspace="5" hspace="5" src="Content/InvertedPendulum/Control/Digital/figures/dstatefeedback_pend2.png" alt=""> </p>
      <p>The next step is to assume that all four states are measurable and design the control gain matrix <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq07190.png" alt="$\mathbf{K}$">. If you refer to the continuous <a href="index96a8.html?example=InvertedPendulum&amp;section=ControlStateSpace">Inverted Pendulum: State-Space Methods for Controller Design</a> page the <b>Linear Quadratic Regulator (LQR)</b> method was used to find the control gain matrix <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq07190.png" alt="$\mathbf{K}$">. In this digital version, we will use the same LQR method. This method allows you to find the control gain that results in
         the optimal balance between system errors and control effort. Please consult your control textbook for details. To use this
         LQR method, we need to specify two parameters, the performance index matrix <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq85930.png" alt="$R$"> and the state-cost matrix <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq26149.png" alt="$\mathbf{Q}$">. For simplicity, we will initially choose the performance index matrix <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq28884.png" alt="$\mathbf{R}$"> equal to 1, and the state-cost matrix <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq26149.png" alt="$\mathbf{Q}$"> equal to <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq05837.png" alt="$\mathbf{C'C}$">. The relative weightings of these two matrices will then be tuned by trial and error. The state-cost matrix <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq26149.png" alt="$\mathbf{Q}$"> has the following structure.
      </p>
      <p><span class="eqn_num">(7)</span><img class="display_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq76361.png" alt="$$Q = C'C =&#xA;\left[{\begin{array}{cccc}&#xA;1 &amp; 0 &amp; 0 &amp; 0 \\&#xA;0 &amp; 0 &amp; 0 &amp; 0 \\&#xA;0 &amp; 0 &amp; 1 &amp; 0 \\&#xA;0 &amp; 0 &amp; 0 &amp; 0 \\&#xA;\end{array}}\right]$$"></p>
      <p>The element in the (1,1) position of <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq26149.png" alt="$\mathbf{Q}$"> represents the weight on the cart's position and the element in the (3,3) position represents the weight on the pendulum's
         angle.
      </p>
      <p>Now we are ready to find the control gain matrix <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq07190.png" alt="$\mathbf{K}$"> and observe the resulting closed-loop response of the system. Since we are designing a digital controller, we will specificially
         employ the MATLAB function <tt>dlqr</tt>. Add the following commands to a your m-file and run it in the MATLAB command window. Note that in the following we are overwriting
         the values of the state-space matrices <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq53374.png" alt="$\mathbf{A}$">, <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq68788.png" alt="$\mathbf{B}$">, <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq50346.png" alt="$\mathbf{C}$">, and <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq76245.png" alt="$\mathbf{D}$"> with their discrete-time equivalents using the model derived with the <tt>c2d</tt> command above.
      </p><pre class="codeinput">A = sys_d.a;
B = sys_d.b;
C = sys_d.c;
D = sys_d.d;
Q = C'*C
R = 1;
[K] = dlqr(A,B,Q,R)

Ac = [(A-B*K)];
Bc = [B];
Cc = [C];
Dc = [D];

states = {<span class="string">'x'</span> <span class="string">'x_dot'</span> <span class="string">'phi'</span> <span class="string">'phi_dot'</span>};
inputs = {<span class="string">'r'</span>};
outputs = {<span class="string">'x'</span>; <span class="string">'phi'</span>};

sys_cl = ss(Ac,Bc,Cc,Dc,Ts,<span class="string">'statename'</span>,states,<span class="string">'inputname'</span>,inputs,<span class="string">'outputname'</span>,outputs);

t = 0:0.01:5;
r =0.2*ones(size(t));
[y,t,x]=lsim(sys_cl,r,t);
[AX,H1,H2] = plotyy(t,y(:,1),t,y(:,2),<span class="string">'plot'</span>);
set(get(AX(1),<span class="string">'Ylabel'</span>),<span class="string">'String'</span>,<span class="string">'cart position (m)'</span>)
set(get(AX(2),<span class="string">'Ylabel'</span>),<span class="string">'String'</span>,<span class="string">'pendulum angle (radians)'</span>)
title(<span class="string">'Step Response with Digital LQR Control'</span>)
</pre><pre class="codeoutput">Q =
     1     0     0     0
     0     0     0     0
     0     0     1     0
     0     0     0     0
K =
   -0.9384   -1.5656   18.0351    3.3368
</pre><img class="figure"vspace="5" hspace="5" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_01.png" alt=""> <p>The curve in green represents the pendulum's angle in radians, and the curve in blue represents the cart's position in meters.
         As you can see, this plot is not satisfactory. The pendulum and cart's overshoot appear fine, but their settling times need
         improvement and the cart's rise time needs to be reduced. As I'm sure you have noticed, the cart's final position is also
         not near the desired location but has in fact moved in the opposite direction. This error will be dealt with in the next section
         and right now we will focus on the settling and rise times. Go back to your m-file and change the <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq26149.png" alt="$\mathbf{Q}$"> matrix to see if you can get a better response. You will find that increasing the (1,1) and (3,3) elements makes the settling
         and rise times go down, and lowers the angle the pendulum moves. In other words, you are putting more weight on the errors
         at the cost of increased control effort <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq35435.png" alt="$u$">. Modifying your m-file so that the (1,1) element of <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq26149.png" alt="$\mathbf{Q}$"> is 5000 and the (3,3) element is 100, will produce the following value of <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq07190.png" alt="$\mathbf{K}$"> and the step response shown below.
      </p><pre class="codeinput">A = sys_d.a;
B = sys_d.b;
C = sys_d.c;
D = sys_d.d;
Q = C'*C;
Q(1,1) = 5000;
Q(3,3) = 100
R = 1;
[K] = dlqr(A,B,Q,R)

Ac = [(A-B*K)];
Bc = [B];
Cc = [C];
Dc = [D];

states = {<span class="string">'x'</span> <span class="string">'x_dot'</span> <span class="string">'phi'</span> <span class="string">'phi_dot'</span>};
inputs = {<span class="string">'r'</span>};
outputs = {<span class="string">'x'</span>; <span class="string">'phi'</span>};

sys_cl = ss(Ac,Bc,Cc,Dc,Ts,<span class="string">'statename'</span>,states,<span class="string">'inputname'</span>,inputs,<span class="string">'outputname'</span>,outputs);

t = 0:0.01:5;
r =0.2*ones(size(t));
[y,t,x]=lsim(sys_cl,r,t);
[AX,H1,H2] = plotyy(t,y(:,1),t,y(:,2),<span class="string">'plot'</span>);
set(get(AX(1),<span class="string">'Ylabel'</span>),<span class="string">'String'</span>,<span class="string">'cart position (m)'</span>)
set(get(AX(2),<span class="string">'Ylabel'</span>),<span class="string">'String'</span>,<span class="string">'pendulum angle (radians)'</span>)
title(<span class="string">'Step Response with Digital LQR Control'</span>)
</pre><pre class="codeoutput">Q =
        5000           0           0           0
           0           0           0           0
           0           0         100           0
           0           0           0           0
K =
  -61.9933  -33.5040   95.0597   18.8300
</pre><img class="figure"vspace="5" hspace="5" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_02.png" alt=""> <p>From this plot, we see that all design requirements are satisfied except the steady-state error of the cart position <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq43551.png" alt="$x$">. We can easily correct this by introducing a feedforward scaling factor <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq94609.png" alt="$\bar{N}$">.
      </p>
      <h2>Precompensator design<a name="14"></a></h2>
      <p>Unlike other design methods, the full-state feedback system does not compare the output directly to the reference, rather,
         it compares the state vector multiplied by the control matrix (<img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq82255.png" alt="$\mathbf{Kx}$">) to the reference (see the schematic shown above). Thus, we should not expect the output to converge to the commanded reference.
         To obtain the desired output, we need to scale the reference input so that the output equals the reference. This can be easily
         done by introducing a feedforward scaling factor <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq94609.png" alt="$\bar{N}$">. The basic full state-feedback schematic with scaling factor is shown below.
      </p>
      <p><img class="figure"vspace="5" hspace="5" src="Content/InvertedPendulum/Control/Digital/figures/dstatefeedback_w_pre_pend.png" alt=""> </p>
      <p>Unfortunately, we cannot use our user-defined function <tt>rscale</tt> to find <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq94609.png" alt="$\bar{N}$"> because this function was defined for continuous-time single-output systems. We can, however, find the scaling factor by
         trial and error. After several trials, <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq94609.png" alt="$\bar{N}$"> equal to -61.55 provided a satisfactory response. Adding the following commands to your m-file and running in the command
         window will generate the response shown below.
      </p><pre class="codeinput">Nbar = -61.55;
sys_cl = ss(Ac,Bc*Nbar,Cc,Dc,Ts,<span class="string">'statename'</span>,states,<span class="string">'inputname'</span>,inputs,<span class="string">'outputname'</span>,outputs);

t = 0:0.01:5;
r =0.2*ones(size(t));
[y,t,x]=lsim(sys_cl,r,t);
[AX,H1,H2] = plotyy(t,y(:,1),t,y(:,2),<span class="string">'plot'</span>);
set(get(AX(1),<span class="string">'Ylabel'</span>),<span class="string">'String'</span>,<span class="string">'cart position (m)'</span>)
set(get(AX(2),<span class="string">'Ylabel'</span>),<span class="string">'String'</span>,<span class="string">'pendulum angle (radians)'</span>)
title(<span class="string">'Step Response with Digital LQR Control and Precompensation'</span>)
</pre><img class="figure"vspace="5" hspace="5" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_03.png" alt=""> <p>Notice that the steady-state error of the cart's position has been eliminated.  Now we have designed a system that satisfies
         all of the design requirements. Note, however, that the scaling factor <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq94609.png" alt="$\bar{N}$"> was designed based on a model of the system. If our model is in error or there are unknown disturbances, then the steady-state
         error will no longer be driven to zero.
      </p>
      <h2>Observer design<a name="16"></a></h2>
      <p>The above response satisfies all of the design requirements, however, it was found assuming all state variables of the system
         are measurable. This assumption may not be valid for all systems. In this section, we develop a technique for estimating the
         state of the system based on the measured outputs and a model of the plant. The object that estimates the state of system
         is called an <b>observer</b>. Thus, in this section we will design a full-order state observer to estimate all of the system's state variables, including
         those that are measured. For further explanation on how an observer works, please consult your control textbook.
      </p>
      <p>A basic schematic of the observer-based state-feedback system is shown below.</p>
      <p><img class="figure"vspace="5" hspace="5" src="Content/InvertedPendulum/Control/Digital/figures/dobserver_statefeedback_pend.png" alt=""> </p>
      <p>Designing the observer equates to finding the observer gain matrix <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq15477.png" alt="$\mathbf{L}$">. To accomplish this, we need to first determine the closed-loop poles of the system without the observer (the eigenvalues
         of <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq21909.png" alt="$$\mathbf{A-BK}$">). This can be achieved using the MATLAB command <tt>eig</tt> as shown below.
      </p><pre class="codeinput">poles = eig(A-B*K)
</pre><pre class="codeoutput">poles =
   0.9157 + 0.0728i
   0.9157 - 0.0728i
   0.9535 + 0.0079i
   0.9535 - 0.0079i
</pre><p>Since the observer is attempting to estimate the values of state variables which are themselves changing, it is desired that
         the dynamics of the observer be significantly faster than the dynamics of the closed-loop system without the observer. A common
         guideline is to make the estimator poles (eigenvalues of <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq38229.png" alt="$\mathbf{A-LC}$">) 4-10 times faster than the slowest controller pole (eigenvalue of <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq54141.png" alt="$\mathbf{A-BK}$">). Making the estimator poles too fast can be problematic if the measurement is corrupted by noise or there are errors in
         the sensor measurement in general.  Based on the poles found above, we will place the observer poles at [-0.2 -0.21 -0.22
         -0.23]. These poles can be modified later, if necessary. We will use the MATLAB function <tt>place</tt> to find the <img class="inline_eqn" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_eq15477.png" alt="$\mathbf{L}$"> matrix. Add the following code to your m-file and re-run in the command window to generate the observer gain matrix shown
         below.
      </p><pre class="codeinput">P = [-0.2 -0.21 -0.22 -0.23];
L = place(A',C',P)'
</pre><pre class="codeoutput">L =
    2.4308   -0.0104
  147.6324   -1.2418
   -0.0131    2.4305
   -1.8079  147.9057
</pre><p>Now we will obtain the overall system response including the observer. Add the following commands to your m-file and run to
         generate the response shown below.
      </p><pre class="codeinput">Ace = [(A-B*K) (B*K);
       zeros(size(A)) (A-L*C)];
Bce = [B*Nbar;
       zeros(size(B))];
Cce = [Cc zeros(size(Cc))];
Dce = [0;0];

states = {<span class="string">'x'</span> <span class="string">'x_dot'</span> <span class="string">'phi'</span> <span class="string">'phi_dot'</span> <span class="string">'e1'</span> <span class="string">'e2'</span> <span class="string">'e3'</span> <span class="string">'e4'</span>};
inputs = {<span class="string">'r'</span>};
outputs = {<span class="string">'x'</span>; <span class="string">'phi'</span>};

sys_est_cl = ss(Ace,Bce,Cce,Dce,Ts,<span class="string">'statename'</span>,states,<span class="string">'inputname'</span>,inputs,<span class="string">'outputname'</span>,outputs);

t = 0:0.01:5;
r = 0.2*ones(size(t));
[y,t,x]=lsim(sys_est_cl,r,t);
[AX,H1,H2] = plotyy(t,y(:,1),t,y(:,2),<span class="string">'plot'</span>);
set(get(AX(1),<span class="string">'Ylabel'</span>),<span class="string">'String'</span>,<span class="string">'cart position (m)'</span>)
set(get(AX(2),<span class="string">'Ylabel'</span>),<span class="string">'String'</span>,<span class="string">'pendulum angle (radians)'</span>)
title(<span class="string">'Step Response with Digital Observer-Based State-Feedback Control'</span>)
</pre><img class="figure"vspace="5" hspace="5" src="Content/InvertedPendulum/Control/Digital/html/InvertedPendulum_ControlDigital_04.png" alt=""> <p>This response is almost identical to the response achieved when it was assumed that we had full access to the state variables.
         This is because the observer poles are fast, and because the model we assumed for the observer is identical to the model of
         the actual plant (including the same initial conditions). Therefore, all of the design requirements have been met with the
         minimal control effort expended. No further iteration is needed.
      </p>
      <p class="footer"><br>
         Published with MATLAB&reg; 8.0<br></p>
   </div>
</div>
<!--
##### SOURCE BEGIN #####
%% Inverted Pendulum: Digital Controller Design
%
% Key MATLAB commands used in this tutorial are:
% <http://www.mathworks.com/help/toolbox/control/ref/ss.html |ss|> , 
% <http://www.mathworks.com/help/toolbox/control/ref/c2d.html |c2d|> ,
% <http://www.mathworks.com/help/toolbox/control/ref/ctrb.html |ctrb|> ,
% <http://www.mathworks.com/help/toolbox/control/ref/obsv.html |obsv|> ,
% <http://www.mathworks.com/help/toolbox/control/ref/dlqr.html |dlqr|> ,
% <http://www.mathworks.com/help/toolbox/control/ref/lsim.html |lsim|> ,
% <http://www.mathworks.com/help/toolbox/rf/plotyy.html |plotyy|> , 
% <http://www.mathworks.com/help/techdoc/ref/eig.html |eig|> , 
% <http://www.mathworks.com/help/toolbox/control/ref/place.html |place|>
%
%%
% In this digital control version of the inverted pendulum problem, we will
% use the state-space method to design the digital controller. If you refer to the
% < ?example=InvertedPendulum&section=SystemModeling Inverted Pendulum: System Modeling> page,
% the linearized state-space equations were derived as:
%
% $$
% \left[{\begin{array}{c}
%   \dot{x}\\ \ddot{x}\\ \dot{\phi}\\ \ddot{\phi}
% \end{array}}\right] =
% \left[{\begin{array}{cccc}
%   0&1&0&0\\ 
%   0&\frac{-(I+ml^2)b}{I(M+m)+Mml^2}&\frac{m^2gl^2}{I(M+m)+Mml^2}&0\\ 
%   0&0&0&1\\ 
%   0&\frac{-mlb}{I(M+m)+Mml^2}&\frac{mgl(M+m)}{I(M+m)+Mml^2}&0
% \end{array}}\right]
% \left[{\begin{array}{c}
%   x\\ \dot{x}\\ \phi\\ \dot{\phi}
% \end{array}}\right]+
% \left[{\begin{array}{c}0\\ 
%   \frac{I+ml^2}{I(M+m)+Mml^2}\\ 
%   0 \\
%   \frac{ml}{I(M+m)+Mml^2} 
% \end{array}}\right]u$$
% 
% $${\bf y} = 
% \left[{\begin{array}{cccc}
%   1&0&0&0\\0&0&1&0
% \end{array}}\right]
% \left[{\begin{array}{c}
%   x\\ \dot{x}\\ \phi\\ \dot{\phi}
% \end{array}}\right]+
% \left[{\begin{array}{c}
%   0\\0
% \end{array}}\right]u$$
%
% where:
%
%  (M)       mass of the cart                         0.5 kg
% 
%  (m)       mass of the pendulum                     0.2 kg
% 
%  (b)       coefficient of friction for cart         0.1 N/m/sec
% 
%  (l)       length to pendulum center of mass        0.3 m
% 
%  (I)       mass moment of inertia of the pendulum   0.006 kg.m^2
% 
%  (F)       force applied to the cart	
% 
%  (x)       cart position coordinate	
% 
%  (theta)   pendulum angle from vertical (down)	
%
%%
% For this problem the outputs are the cart's displacement ($x$ in meters)
% and the pendulum angle ($\phi$ in radians) where $\phi$ represents the deviation of
% the pedulum's position from equilibrium, that is, $\theta$ = $\pi$ + $\phi$.
%
%%
% The design criteria for this system for a 0.2-m step in desired cart
% position $x$ are as follows: 
%
% * Settling time for $x$ and _theta_ of less than 5 seconds
% * Rise time for $x$ of less than 0.5 seconds
% * Pendulum angle $\theta$ never more than 20 degrees (0.35 radians) from
% the vertical
% * Steady-state error of less than 2% for $x$ and $\theta$ 
%
%% Discrete state-space
% Our first step in designing a digital controller is to convert the above
% continuous state-space equations to a discrete form. We will accomplish
% this employing the MATLAB function |c2d|. This function requires that we
% specify three arguments: a continuous system model, the sampling
% time (|Ts| in sec/sample), and the |'method'|. You should already be
% familiar with how to construct a state-space system from $\mathbf{A}$, $\mathbf{B}$, $\mathbf{C}$,
% and $\mathbf{D}$ matrices.     
%
% In choosing a sample time, note that it is desired that the sampling
% frequency be fast compared to the dynamics of the system. One measure of
% a system's "speed" is its closed-loop bandwidth. A good rule of thumb is
% that the sampling time be smaller than 1/30th of the closed-loop
% bandwidth frequency which can be determined from the closed-loop Bode
% plot.
%
% Assuming that the closed-loop bandwidth frequencies are around 1 rad/sec
% for both the cart and the pendulum, let the sampling time be 1/100 
% sec/sample. The discretization method we will use is the *zero-order
% hold* (|'zoh'|). For further details, refer to the 
% < ?example=Introduction&section=ControlDigital
% Introduction: Digital Controller Design> page. Now we are ready to use
% |c2d| function. Enter the following commands into an
% < ?aux=Extras_Mfile m-file>. Running
% this m-file in the MATLAB command window gives you the following four
% matrices representing the discrete time state-space model.  

M = 0.5;
m = 0.2;
b = 0.1;
I = 0.006;
g = 9.8;
l = 0.3;

p = I*(M+m)+M*m*l^2; %denominator for the A and B matrices

A = [0      1              0           0;
     0 -(I+m*l^2)*b/p  (m^2*g*l^2)/p   0;
     0      0              0           1;
     0 -(m*l*b)/p       m*g*l*(M+m)/p  0];
B = [     0; 
     (I+m*l^2)/p;
          0;
        m*l/p];
C = [1 0 0 0;
     0 0 1 0];
D = [0;
     0];
 
states = {'x' 'x_dot' 'phi' 'phi_dot'};
inputs = {'u'};
outputs = {'x'; 'phi'};

sys_ss = ss(A,B,C,D,'statename',states,'inputname',inputs,'outputname',outputs);

Ts = 1/100;

sys_d = c2d(sys_ss,Ts,'zoh')

%%
% Now we have obtained the discrete state-space model of the form:
%
% $$\left[{\begin{array}{c}
% x(k+1)\\ \dot{x}(k+1)\\ \*\phi(k+1)\\ *\dot{\phi}(k+1)
% \end{array}}\right]=
% \left[{\begin{array}{cccc}
% 1&0.01&0.0001&0\\ 
% 0&0.9982&0.0267&0.0001\\ 
% 0&0&1.0016&0.01\\ 
% 0&-0.0045&0.3119&1.0016
% \end{array}}\right]
% \left[{\begin{array}{c}
% x(k)\\ \dot{x}(k)\\ *\phi(k)\\ *\dot{\phi}(k)
% \end{array}}\right]
% +
% \left[{\begin{array}{c}
% 0.0001\\ 0.0182\\ 0.0002\\ 0.0454
% \end{array}}\right]u(k)$$
% 
% $${\bf y}(k) = \left[{\begin{array}{cccc}1&0&0&0\\0&0&1&0\end{array}}\right]
% \left[{\begin{array}{c}
% x(k)\\ \dot{x}(k)\\ *\phi(k)\\ *\dot{\phi}(k)
% \end{array}}\right]
% +\left[{\begin{array}{c}0\\0\end{array}}\right]u(k)$$
%
%% Controllability and observability
% The next step is to check the controllability and the observability of
% the system. For the system to be completely state controllable, the 
% controllability matrix
%
%%
% $$C = 
% \left[{\begin{array}{ccccc}
% B & AB & A^2B & \cdots & A^{n-1}B
% \end{array}}\right]$$
%
%%
% must have the *rank of n*. The rank of the matrix is the number of
% independent rows (or columns). In the same token, for the system to be 
% completely state observable, the observability matrix 
%
% $$O = 
% \left[{\begin{array}{c}
% C \\ CA \\ \vdots \\ CA^{n-1}
% \end{array}}\right]$$
%
% must also have the *rank of n*. These tests for controllability and
% observability are identical to the situation of continuous control except
% that now the state space model is discrete.
%
% Since the number of state variables in our system is 4, the
% rank of both matrices must be 4. The function |rank| can give you the 
% rank of each matrix. Adding the following commands to your m-file and
% running in the MATLAB command window will generate the results shown
% below.

co = ctrb(sys_d);
ob = obsv(sys_d);

controllability = rank(co)
observability = rank(ob)

%%
% This proves that our discrete system is both completely state
% controllable and completely state observable.
%
%% Control design via pole placement
% The schematic of a full-state feedback control system is shown below.
%
% <<Content/InvertedPendulum/Control/Digital/figures/dstatefeedback_pend2.png>>
%
% The next step is to assume that all four states are measurable and design
% the control gain matrix $\mathbf{K}$. If you refer to the continuous 
% < ?example=InvertedPendulum&section=ControlStateSpace
% Inverted Pendulum: State-Space Methods for Controller Design> page the *Linear Quadratic Regulator 
% (LQR)* method was used to find the control gain matrix $\mathbf{K}$. In this digital 
% version, we will use the same LQR method. This method allows you to find 
% the control gain that results in the optimal balance between system 
% errors and control effort. Please consult your control textbook for 
% details. To use this LQR method, we need to specify two parameters, the 
% performance index matrix $R$ and the state-cost matrix $\mathbf{Q}$. For
% simplicity, we will initially choose the performance index matrix $\mathbf{R}$ equal to 1,
% and the state-cost matrix $\mathbf{Q}$ equal to $\mathbf{C'C}$. The relative
% weightings of these two matrices will then be tuned by trial and error.
% The state-cost matrix $\mathbf{Q}$ has the following structure.
%
% $$Q = C'C =  
% \left[{\begin{array}{cccc}
% 1 & 0 & 0 & 0 \\
% 0 & 0 & 0 & 0 \\
% 0 & 0 & 1 & 0 \\
% 0 & 0 & 0 & 0 \\
% \end{array}}\right]$$
%
% The element in the (1,1) position of $\mathbf{Q}$ represents the weight on the
% cart's position and the element in the (3,3) position represents the
% weight on the pendulum's angle. 
%%
% Now we are ready to find the control gain matrix $\mathbf{K}$ and observe the
% resulting closed-loop response of the system. Since we are designing a
% digital controller, we will 
% specificially employ the MATLAB function |dlqr|. Add the following
% commands to a your m-file and run it in the MATLAB command window. Note
% that in the following we are overwriting the values of the state-space
% matrices $\mathbf{A}$, $\mathbf{B}$, $\mathbf{C}$, and $\mathbf{D}$ with their discrete-time equivalents
% using the model derived with the |c2d| command above. 

A = sys_d.a;
B = sys_d.b;
C = sys_d.c;
D = sys_d.d;
Q = C'*C
R = 1;
[K] = dlqr(A,B,Q,R) 

Ac = [(A-B*K)];
Bc = [B];
Cc = [C];
Dc = [D];

states = {'x' 'x_dot' 'phi' 'phi_dot'};
inputs = {'r'};
outputs = {'x'; 'phi'};

sys_cl = ss(Ac,Bc,Cc,Dc,Ts,'statename',states,'inputname',inputs,'outputname',outputs);

t = 0:0.01:5;
r =0.2*ones(size(t));
[y,t,x]=lsim(sys_cl,r,t);
[AX,H1,H2] = plotyy(t,y(:,1),t,y(:,2),'plot');
set(get(AX(1),'Ylabel'),'String','cart position (m)') 
set(get(AX(2),'Ylabel'),'String','pendulum angle (radians)') 
title('Step Response with Digital LQR Control')

%%
% The curve in green represents the pendulum's angle in radians, and the
% curve in blue represents the cart's position in meters. As you can see, 
% this plot is not satisfactory. The pendulum and cart's overshoot appear 
% fine, but their settling times need improvement and the cart's rise time 
% needs to be reduced. As I'm sure you have noticed, the cart's final position is also not near the 
% desired location but has in fact moved in the opposite direction. This error
% will be dealt with in the next section and right now we will focus on the
% settling and rise times. Go back to your m-file and change the $\mathbf{Q}$ matrix
% to see if you can get a better response. You will find that increasing
% the (1,1) and (3,3) elements makes the settling and rise times go down,
% and lowers the angle the pendulum moves. In other words, you are putting
% more weight on the errors at the cost of increased control effort $u$. 
% Modifying your m-file so that the (1,1) element of $\mathbf{Q}$ is 5000 and the
% (3,3) element is 100, will produce the following value of $\mathbf{K}$ and the
% step response shown below.

A = sys_d.a;
B = sys_d.b;
C = sys_d.c;
D = sys_d.d;
Q = C'*C;
Q(1,1) = 5000;
Q(3,3) = 100
R = 1;
[K] = dlqr(A,B,Q,R) 

Ac = [(A-B*K)];
Bc = [B];
Cc = [C];
Dc = [D];

states = {'x' 'x_dot' 'phi' 'phi_dot'};
inputs = {'r'};
outputs = {'x'; 'phi'};

sys_cl = ss(Ac,Bc,Cc,Dc,Ts,'statename',states,'inputname',inputs,'outputname',outputs);

t = 0:0.01:5;
r =0.2*ones(size(t));
[y,t,x]=lsim(sys_cl,r,t);
[AX,H1,H2] = plotyy(t,y(:,1),t,y(:,2),'plot');
set(get(AX(1),'Ylabel'),'String','cart position (m)') 
set(get(AX(2),'Ylabel'),'String','pendulum angle (radians)') 
title('Step Response with Digital LQR Control')

%%
% From this plot, we see that all design requirements are satisfied except
% the steady-state error of the cart position $x$. We can easily correct 
% this by introducing a feedforward scaling factor $\bar{N}$.
%
%% Precompensator design
% Unlike other design methods, the full-state feedback system does not
% compare the output directly to the reference, rather, it compares the state vector 
% multiplied by the control matrix ($\mathbf{Kx}$) to the reference (see the 
% schematic shown above). Thus, we should not expect the output to 
% converge to the commanded reference. To obtain the desired output, we
% need to scale the reference input so that the output equals the
% reference. This can be easily done by introducing a feedforward scaling factor $\bar{N}$. 
% The basic full state-feedback schematic with scaling factor is shown below.
%
% <<Content/InvertedPendulum/Control/Digital/figures/dstatefeedback_w_pre_pend.png>>
%
% Unfortunately, we cannot use our user-defined function |rscale| to find
% $\bar{N}$ because this function was defined for continuous-time
% single-output systems. We can, however, find the scaling factor by trial
% and error. After several trials, $\bar{N}$ equal to -61.55 provided a
% satisfactory response. Adding the following commands to your m-file and
% running in the command window will generate the response shown below.

       
Nbar = -61.55;
sys_cl = ss(Ac,Bc*Nbar,Cc,Dc,Ts,'statename',states,'inputname',inputs,'outputname',outputs);

t = 0:0.01:5;
r =0.2*ones(size(t));
[y,t,x]=lsim(sys_cl,r,t);
[AX,H1,H2] = plotyy(t,y(:,1),t,y(:,2),'plot');
set(get(AX(1),'Ylabel'),'String','cart position (m)') 
set(get(AX(2),'Ylabel'),'String','pendulum angle (radians)') 
title('Step Response with Digital LQR Control and Precompensation')

%%
% Notice that the steady-state error of the cart's position has been
% eliminated.  Now we have designed a system that satisfies all of the
% design requirements. Note, however, that the scaling factor $\bar{N}$ was
% designed based on a model of the system. If our model is in error or
% there are unknown disturbances, then the steady-state error will no
% longer be driven to zero.
%
%% Observer design
% The above response satisfies all of the design requirements, however, it was
% found assuming all state variables of the system are measurable. This
% assumption may not be valid for all systems. In this section, we develop
% a technique for estimating the state of the system based on the measured
% outputs and a model of the plant. The object that estimates the state of
% system is called an *observer*. Thus, in this section we will design a 
% full-order state observer to estimate all of the system's state
% variables, including those that are measured. For further explanation
% on how an observer works, please consult your control textbook. 
%
% A basic schematic of the observer-based state-feedback system is shown below.
%
% <<Content/InvertedPendulum/Control/Digital/figures/dobserver_statefeedback_pend.png>>
%
% Designing the observer equates to finding the observer gain matrix
% $\mathbf{L}$. To accomplish this, we need to first determine the closed-loop poles
% of the system without the observer (the eigenvalues of $$\mathbf{A-BK}$). This
% can be achieved using the MATLAB command |eig| as shown below.

poles = eig(A-B*K)

%%
% Since the observer is attempting to estimate the values of state
% variables which are themselves changing, it is desired that the dynamics
% of the observer be significantly faster than the dynamics of the
% closed-loop system without the observer. A common guideline is to make
% the estimator poles (eigenvalues of $\mathbf{A-LC}$) 4-10 times faster than the
% slowest controller pole (eigenvalue of $\mathbf{A-BK}$). Making the estimator
% poles too fast can be problematic if the measurement is corrupted by
% noise or there are errors in the sensor measurement in 
% general.  Based on the poles found above, we will place the observer
% poles at [-0.2 -0.21 -0.22 -0.23]. These poles can be modified later, if
% necessary. We will use the MATLAB function |place| to find the $\mathbf{L}$
% matrix. Add the following code to your m-file and re-run in the
% command window to generate the observer gain matrix shown below.

P = [-0.2 -0.21 -0.22 -0.23];
L = place(A',C',P)'

%%
% Now we will obtain the overall system response including the observer.
% Add the following commands to your m-file and run to generate the
% response shown below.  

Ace = [(A-B*K) (B*K);
       zeros(size(A)) (A-L*C)];
Bce = [B*Nbar;
       zeros(size(B))];
Cce = [Cc zeros(size(Cc))];
Dce = [0;0];

states = {'x' 'x_dot' 'phi' 'phi_dot' 'e1' 'e2' 'e3' 'e4'};
inputs = {'r'};
outputs = {'x'; 'phi'};

sys_est_cl = ss(Ace,Bce,Cce,Dce,Ts,'statename',states,'inputname',inputs,'outputname',outputs);

t = 0:0.01:5;
r = 0.2*ones(size(t));
[y,t,x]=lsim(sys_est_cl,r,t);
[AX,H1,H2] = plotyy(t,y(:,1),t,y(:,2),'plot');
set(get(AX(1),'Ylabel'),'String','cart position (m)') 
set(get(AX(2),'Ylabel'),'String','pendulum angle (radians)') 
title('Step Response with Digital Observer-Based State-Feedback Control')

%%
% This response is almost identical to the response achieved when it was
% assumed that we had full access to the state variables. This is because
% the observer poles are fast, and because the model we assumed for the
% observer is identical to the model of the actual plant (including the
% same initial conditions). Therefore, all of 
% the design requirements have been met with the minimal control
% effort expended. No further iteration is needed.

##### SOURCE END #####
-->				</div>
				
				<div id="left">

					<ul class="section">
						<li class="heading" id="System">SYSTEM<img class="section_heading_arrow" src="Images/section_heading_arrow.png"/></li>
						<li class="item" id="SystemModeling"><a href="indexdeb1.html?example=InvertedPendulum&amp;section=SystemModeling">MODELING<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
						<li class="item" id="SystemAnalysis"><a href="indexce00.html?example=InvertedPendulum&amp;section=SystemAnalysis">ANALYSIS<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
					</ul>
					
					<div class="section_break"></div>

					<ul class="section">
						<li class="heading" id="Control">CONTROL<img class="section_heading_arrow" src="Images/section_heading_arrow.png"/></li>
						<li class="item" id="ControlPID"><a href="index9b2d.html?example=InvertedPendulum&amp;section=ControlPID">PID<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
						<li class="item" id="ControlRootLocus"><a href="index2ed1.html?example=InvertedPendulum&amp;section=ControlRootLocus">ROOT&nbsp;LOCUS<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
						<li class="item" id="ControlFrequency"><a href="index64c4.html?example=InvertedPendulum&amp;section=ControlFrequency">FREQUENCY<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
						<li class="item" id="ControlStateSpace"><a href="index96a8.html?example=InvertedPendulum&amp;section=ControlStateSpace">STATE-SPACE<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
						<li class="item" id="ControlDigital"><a href="index5759.html?example=InvertedPendulum&amp;section=ControlDigital">DIGITAL<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
					</ul>
					
					<div class="section_break"></div>

					<ul class="section">
						<li class="heading" id="Simulink">SIMULINK<img class="section_heading_arrow" src="Images/section_heading_arrow.png"/></li>
						<li class="item" id="SimulinkModeling"><a href="indexffaa.html?example=InvertedPendulum&amp;section=SimulinkModeling">MODELING<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
						<li class="item" id="SimulinkControl"><a href="indexd477.html?example=InvertedPendulum&amp;section=SimulinkControl">CONTROL<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
					</ul>
		
				</div>
			
				<div style="clear:both"></div>
				
				<div id="bottombar"><span style="color:#FF5500;font-weight:bold">.</div>
				
			</div>
			
		</div>
	
		<script type="text/javascript" src="script.js"></script>
						
	</body>
	

<!-- Mirrored from ctms.engin.umich.edu/CTMS/index.php?example=InvertedPendulum&section=ControlDigital by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 19 Jun 2014 21:05:38 GMT -->
</html>

	rolDigital by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 19 Jun 2014 21:05:38 GMT -->
</html>

			<script type="text/javascript" src="script.js"></script>
						
	</body>
	

<!-- Mirrored from ctms.engin.umich.edu/CTMS/index.php?example=InvertedPendulum&section=ControlDigital by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 19 Jun 2014 21:05:38 GMT -->
</html>

	rolDigital by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 19 Jun 2014 21:05:38 GMT -->
</html>

	pier/3.x [XR&CO'2014], Thu, 19 Jun 2014 21:05:38 GMT -->
</html>

	rolDigital by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 19 Jun 2014 21:05:38 GMT -->
</html>

	