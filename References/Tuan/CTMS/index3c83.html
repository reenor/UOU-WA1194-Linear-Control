<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

	
<!-- Mirrored from ctms.engin.umich.edu/CTMS/index.php?example=MotorPosition&section=ControlRootLocus by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 19 Jun 2014 21:10:40 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>

		<script type="text/javascript" src="jquery.js"></script>
					
		<link rel='stylesheet' type='text/css' href='style.css' />
		<script type="text/javascript">
	
			var example = "MotorPosition"; 
			var section = "ControlRootLocus"; 
			var aux = ""; 
			var effects = Boolean(1); 
			var tips = Boolean(1); 
			$.fx.off = !effects;
			
			$(document).keydown(function(e){
				if (!$("#search_field").is(":focus")){
					if (e.keyCode == 39) { 
						window.location = "index1ae7.html?example=MotorPosition&amp;section=ControlFrequency";
					}
					if (e.keyCode == 37) { 
						window.history.back()
					}
				}
			});		
			
		</script>
			
		<meta http-equiv="Content-Type" Content="text/html; charset=utf-8" />
		<meta http-equiv="PRAGMA" Content="NO-CACHE" />
		
		<title>Control Tutorials for MATLAB and Simulink - Motor Position: Root Locus Controller Design</title>
			
	</head>

	<body>
	
		
		<div id="container">
		
			<form id="search_form"><input id="search_field" type="text" name="q" placeholder="Search Control Tutorials"/></form>
			<form class="option_form" method="post" onclick="submit()"><div>Effects</div><input type="hidden" name="effects" value="0"/><input type="checkbox" name="effects" value="1" checked='true' /></form>
			<form class="option_form" method="post" onclick="submit()"><div>Tips</div><input type="hidden" name="tips" value="0"/><input type="checkbox" name="tips" value="1" checked='true' /></form>	
				
			<div style="clear:both"></div>
		
			<div id="header">
		
				

				
				
				<div id="menu_container">
				
					<ul class="menu">
						<li class="heading" id="Tips"><a href="index80e7.html?aux=Extras_Tips">TIPS</a></li>
						<div class="collapse"><div class="expand">
						</div></div>
					</ul>
				
					<ul class="menu">
						<li class="heading" id="About"><a>ABOUT</a></li>
						<div class="collapse"><div class="expand">
							<li class="item" id="About_Tutorials"><a href="index64fe.html?aux=About_Tutorials">Tutorials</a></li>
							<li class="item" id="About_Contact"><a href="mailto:ControlTutorialsMatlabSimulink@gmail.com">Contact</a></li>
						</div></div>
					</ul>
					
					<ul class="menu">
						<li class="heading" id="Basics"><a>BASICS</a></li>
						<div class="collapse"><div class="expand">
							<li class="item" id="Basics_Matlab"><a href="index87b6.html?aux=Basics_Matlab">MATLAB</a></li>
							<li class="item" id="Basics_Simulink"><a href="indexe9ea.html?aux=Basics_Simulink">Simulink</a></li>
						</div></div>
					</ul>
					
					<ul class="menu">
						<li class="heading" id="Index"><a>INDEX</a></li>
						<div class="collapse"><div class="expand">
							<li class="item" id="Index_Tutorials"><a href="index5e52.html?aux=Index_Tutorials">Tutorials</a></li>
							<li class="item" id="Index_Commands"><a href="index111e.html?aux=Index_Commands">Commands</a></li>
							<li class="item" id="Index_Animations"><a href="indexc3c5.html?aux=Index_Animations">Animations</a></li>
							<li class="item" id="Index_Extras"><a href="indexb290.html?aux=Index_Extras">Extras</a></li>
						</div></div>
					</ul>
									
					<ul class="menu">
						<li class="heading" id="Next"><a href="index1ae7.html?example=MotorPosition&amp;section=ControlFrequency">NEXT&nbsp;&#x25BA;</a></li>
						<div class="collapse"><div class="expand">
						</div></div>
					</ul>
											
				</div>

			</div>
			
			<div id="body_container">
			
				<div id="gradient_container"></div>
			
				<div id="top">
				
					<a href="index1304.html?aux=Home"><img id="CTMS_logo" src="Images/CTMS_logo.png"></a>
				
					<ul class="example">
					
						<li class="item" id="Introduction"><a href="indexe528.html?example=Introduction&amp;section=ControlRootLocus"><img class="icon" src="Images/Introduction_Icon.png"><div class="tab">INTRODUCTION</div></a></li>
						<li class="item" id="CruiseControl"><a href="index4431.html?example=CruiseControl&amp;section=ControlRootLocus"><img class="icon" src="Images/CruiseControl_Icon.png"><div class="tab">CRUISE&nbsp;CONTROL</div></a></li>
						<li class="item" id="MotorSpeed"><a href="index9e58.html?example=MotorSpeed&amp;section=ControlRootLocus"><img class="icon" src="Images/MotorSpeed_Icon.png"><div class="tab">MOTOR&nbsp;SPEED</div></a></li>
						<li class="item" id="MotorPosition"><a href="index3c83.html?example=MotorPosition&amp;section=ControlRootLocus"><img class="icon" src="Images/MotorPosition_Icon.png"><div class="tab">MOTOR&nbsp;POSITION</div></a></li>
						<li class="item" id="Suspension"><a href="index8618.html?example=Suspension&amp;section=ControlRootLocus"><img class="icon" src="Images/Suspension_Icon.png"><div class="tab">SUSPENSION</div></a></li>
						<li class="item" id="InvertedPendulum"><a href="index2ed1.html?example=InvertedPendulum&amp;section=ControlRootLocus"><img class="icon" src="Images/InvertedPendulum_Icon.png"><div class="tab">INVERTED&nbsp;PENDULUM</div></a></li>
						<li class="item" id="AircraftPitch"><a href="index559a.html?example=AircraftPitch&amp;section=ControlRootLocus"><img class="icon" src="Images/AircraftPitch_Icon.png"><div class="tab">AIRCRAFT&nbsp;PITCH</div></a></li>
						<li class="item" id="BallBeam"><a href="indexc9b8.html?example=BallBeam&amp;section=ControlRootLocus"><img class="icon" src="Images/BallBeam_Icon.png"><div class="tab">BALL&nbsp;&amp;&nbsp;BEAM</div></a></li>
					
					</ul> 
		
				</div>
				
				<div id="content_container">
					<div class="content">
   <div class="content_fx">
      <h1>DC Motor Position: Root Locus Controller Design</h1>
      <!--introduction-->
      <p>Key MATLAB commands used in this tutorial are: <a href="http://www.mathworks.com/help/toolbox/control/ref/tf.html"><tt>tf</tt></a> , <a href="http://www.mathworks.com/help/toolbox/control/ref/rlocus.html"><tt>rlocus</tt></a> , <a href="http://www.mathworks.com/help/toolbox/control/ref/sgrid.html"><tt>sgrid</tt></a> , <a href="http://www.mathworks.com/help/toolbox/control/ref/pole.html"><tt>pole</tt></a> , <a href="http://www.mathworks.com/help/toolbox/control/ref/minreal.html"><tt>minreal</tt></a> , <a href="http://www.mathworks.com/help/toolbox/control/ref/feedback.html"><tt>feedback</tt></a> , <a href="http://www.mathworks.com/help/toolbox/control/ref/step.html"><tt>step</tt></a></p>
      <!--/introduction-->
      <h2>Contents</h2>
      <div>
         <ul>
            <li><a href="#4">Drawing the open-loop root locus</a></li>
            <li><a href="#8">Model reduction</a></li>
            <li><a href="#15">Integral control</a></li>
            <li><a href="#17">PI control</a></li>
            <li><a href="#19">PID control</a></li>
            <li><a href="#22">Determining gain using rlocfind command</a></li>
         </ul>
      </div>
      <p>From the main problem, the open-loop transfer function of the DC Motor is given as follows.</p>
      <p><span class="eqn_num">(1)</span><img class="display_eqn" src="Content/MotorPosition/Control/RootLocus/html/MotorPosition_ControlRootLocus_eq78774.png" alt="$$ P(s) = \frac {\Theta (s)}{V(s)} = \frac{K}{s ( (Js + b)(Ls + R) + K^2 )} \qquad [ \frac{rad}{V}  ] $$"></p>
      <p>The structure of the control system has the form shown in the figure below.</p>
      <p><img class="figure"vspace="5" hspace="5" src="Content/MotorPosition/Control/RootLocus/figures/feedback_motorp.png" alt=""> </p>
      <p>For the original problem setup and the derivation of the above equations, please refer to the <a href="index9ba6.html?example=MotorPosition&amp;section=SystemModeling">DC Motor Position: System Modeling</a> page.
      </p>
      <p>With a 1-radian step reference, the design criteria are the following.</p>
      <div>
         <ul>
            <li>Settling time less than 0.040 seconds</li>
            <li>Overshoot less than 16%</li>
            <li>No steady-state error, even in the presence of a step disturbance input</li>
         </ul>
      </div>
      <p>Now let's design a controller using the <b>root locus</b> method.
      </p>
      <p>Create a new <a href="indexd754.html?aux=Extras_Mfile">m-file</a> and type in the following commands (refer to main problem for the details of getting these commands).
      </p><pre class="codeinput">J = 3.2284E-6;
b = 3.5077E-6;
K = 0.0274;
R = 4;
L = 2.75E-6;
s = tf(<span class="string">'s'</span>);
P_motor = K/(s*((J*s+b)*(L*s+R)+K^2));
</pre><h2>Drawing the open-loop root locus<a name="4"></a></h2>
      <p>The main idea of root locus design is to predict the closed-loop response from the root locus plot which depicts possible
         closed-loop pole locations and is drawn from the open-loop transfer function. Then by adding zeros and/or poles via the controller,
         the root locus can be modified in order to achieve a desired closed-loop response. Let's first view the root locus for the
         plant. Add the following commands to the end of your m-file and run it in the MATLAB command window to generate a plot like
         the one shown below.
      </p><pre class="codeinput">rlocus(P_motor)
title(<span class="string">'Root Locus - P Control'</span>)
sgrid(.5, 0)
sigrid(100)
</pre><img class="figure"vspace="5" hspace="5" src="Content/MotorPosition/Control/RootLocus/html/MotorPosition_ControlRootLocus_01.png" alt=""> <p>The commands <tt>sgrid</tt> and <tt>sigrid</tt> are <a href="index7f05.html?aux=Extras_Function">functions</a> that mark regions of the complex plane corresponding to certain parameters. <tt>sgrid</tt> is a function in the Control System Toolbox; however, to use <a href="indexb9cc.html?aux=Extras_sigrid">sigrid</a> you will have to download it <a href="Content/MotorPosition/Control/RootLocus/sigrid.m">here</a>. The variables in the <tt>sgrid</tt> command are the damping ratio (<i>zeta</i> = 0.5) and the natural frequency (<i>Wn</i> = 0). The variable in the <tt>sigrid</tt> command is the <i>sigma</i> term. The <i>zeta</i> and <i>sigma</i> used above correspond to an overshoot of 16% and a settling time of 0.040 seconds, respectively, for a canonical second-order
         system. Even though our motor transfer function is third order, it will be explained that these second-order based definitions
         will work well. No value is given for <i>Wn</i> since we have no requirement on rise time.
      </p>
      <p>From the above figure, the two open-loop poles near the origin cannot be distinguished because the scale of the axes is set
         to show the third pole which is much farther to the left than the other two poles. The MATLAB command <tt>pole</tt> can be employed to determine the exact values of the open-loop poles.
      </p><pre class="codeinput">poles = pole(P_motor)
</pre><pre class="codeoutput">poles =
   1.0e+06 *
         0
   -1.4545
   -0.0001
</pre><p>The open-loop pole located very far to the left (further than -1e6) does not affect the closed-loop dynamics unless very large
         gains are used. These large gains place two of the closed-loop poles in the right-half complex <i>s</i>-plane where the system becomes unstable. Since we will not use gains that will make the closed-loop system unstable, we can
         neglect this pole by performing a model reduction.
      </p>
      <h2>Model reduction<a name="8"></a></h2>
      <p>In general, the real part of a pole indicates how quickly the transient portion of the corresponding mode decays to zero (assuming
         negative real part). Therefore, if you have a transfer function which has one (or more) poles much farther to the left in
         the complex plane (more negative) than the other poles, their effect on the dynamic response will be hidden by the slower,
         more dominant poles. In the case of our motor position example, the transient closed-loop response for small gains will not
         be affected much by the open-loop pole at -1.45e6. The correct way to neglect this pole in order to maintain its steady-state
         contribution is to keep the DC gain of the transfer function the same, as follows:
      </p>
      <p><span class="eqn_num">(2)</span><img class="display_eqn" src="Content/MotorPosition/Control/RootLocus/html/MotorPosition_ControlRootLocus_eq44005.png" alt="$$  H(s) = \frac{G(s)}{s/p + 1} \approx G(s) \textrm{ for } s \ll p $$"></p>
      <p>As shown above, the poles of the open-loop transfer function can be identified using the MATLAB command <tt>pole</tt>. The two poles that dominate are difficult to identify from above because of the scientific notation, but they can be seen
         more clearly by recognizing that they are the first and third elements of the resulting vector which we have named <tt>poles</tt>.
      </p><pre class="codeinput">poles(1), poles(3)
</pre><pre class="codeoutput">ans =
     0
ans =
  -59.2260
</pre><p>We would then like to construct the reduced transfer function to neglect the pole at 1.45e-6 without affecting the steady-state
         behavior of the system. This can be accomplished with the MATLAB command <tt>minreal</tt>. Add the following commands to your m-file and re-run.
      </p><pre class="codeinput">poles = pole(P_motor);
rP_motor = minreal(P_motor*(s/max(abs(poles)) + 1))
</pre><pre class="codeoutput">
rP_motor =
 
      2122
  -------------
  s^2 + 59.23 s
 
Continuous-time transfer function.

</pre><p>You can then check that the other poles have not been affected by again using the <tt>pole</tt> command as shown below.
      </p><pre class="codeinput">pole(rP_motor)
</pre><pre class="codeoutput">ans =
         0
  -59.2260
</pre><p>Now we can draw the root locus of the reduced system. Add the following commands to the end of your m-file and run it in the
         command window.
      </p><pre class="codeinput">rlocus(rP_motor)
title(<span class="string">'Root Locus - P Control'</span>)
axis([ -300 100 -200 200])
sgrid(.5, 0)
sigrid(100)
</pre><img class="figure"vspace="5" hspace="5" src="Content/MotorPosition/Control/RootLocus/html/MotorPosition_ControlRootLocus_02.png" alt=""> <p>If you examined the original root locus near the origin, it would closely approximate the locus of the reduced transfer function
         shown above. We can see from this new plot that the closed-loop poles are never fast enough to meet the settling time requirement
         (that is, they never move to the left of the <i>sigma</i> = 100 vertical line). Also, recall that we need an integrator in the controller (not just in the system) to remove the steady-state
         error due to a constant disturbance.
      </p>
      <h2>Integral control<a name="15"></a></h2>
      <p>Now, let's try using integral control to remove the steady-state error due to a constant disturbance. Modify your m-file such
         that it appears like the following. Note that this adds a 1 / <i>s</i> term to the forward path of the system. Run this m-file and you will obtain a plot like the one shown below.
      </p><pre class="codeinput">C = 1/s;
rlocus(C*rP_motor)
title(<span class="string">'Root Locus - I Control'</span>)
axis([ -300 100 -200 200])
sgrid(.5, 0)
sigrid(100)
</pre><img class="figure"vspace="5" hspace="5" src="Content/MotorPosition/Control/RootLocus/html/MotorPosition_ControlRootLocus_03.png" alt=""> <p>From this root locus we can see that the closed-loop system under integral control is never stable, therefore, a different
         controller must be employed.
      </p>
      <h2>PI control<a name="17"></a></h2>
      <p>Now, let's modify the integral controller to a PI controller. Using PI instead of I control adds a zero to the open-loop system.
         We'll place this zero at <i>s</i> = -20. The zero must lie between the open-loop poles of the system in this case so that the closed-loop system will be stable.
         Change the lines defining the controller in your m-file to the following. Re-run your m-file and you will obtain a plot like
         the one shown below.
      </p><pre class="codeinput">C = (s + 20) / s;
rlocus(C*rP_motor)
title(<span class="string">'Root Locus - PI Control'</span>)
axis([ -300 100 -200 200])
sgrid(.5, 0)
sigrid(100)
</pre><img class="figure"vspace="5" hspace="5" src="Content/MotorPosition/Control/RootLocus/html/MotorPosition_ControlRootLocus_04.png" alt=""> <p>We have managed to stabilize the system and achieve zero steady-state error to a constant disturbance, but the system is still
         not fast enough.
      </p>
      <h2>PID control<a name="19"></a></h2>
      <p>In order to pull the root locus further to the left, to make it faster, we need to place a second open-loop zero, resulting
         in a PID controller. After some experimentation, we place the two PID zeros at <i>s</i> = -60 and <i>s</i> = -70. Change the lines defining the controller in your m-file to the following. Re-run your m-file and you will generate
         a plot like the one shown below.
      </p><pre class="codeinput">C = (s + 60)*(s + 70) / s;
rlocus(C*rP_motor)
title(<span class="string">'Root Locus - PID Control'</span>)
axis([ -300 100 -200 200])
sgrid(.5, 0)
sigrid(100)
</pre><img class="figure"vspace="5" hspace="5" src="Content/MotorPosition/Control/RootLocus/html/MotorPosition_ControlRootLocus_05.png" alt=""> <p>Now, we can see that two of the closed-loop poles can be placed well within both the settling time and percent overshoot requirements.
         The third closed-loop pole moves from the open-loop pole at <i>s</i> = -59.2 to the open-loop zero at <i>s</i> = -60. This closed-loop pole nearly cancels with the zero (which remains in the closed-loop transfer function) because they
         are so close together. Therefore, we can neglect its effect.  Let's reduce our new model again by performing the zero-pole
         cancelation using the <b>minreal</b> command. We pass 0.1 as a tolerance parameter as follows. The root locus for this further reduced system with controller
         is shown below. Note how closely it resembles the root locus without the pole-zero cancelation.
      </p><pre class="codeinput">rsys_ol = minreal(C*rP_motor, 0.1);
rlocus(rsys_ol)
title(<span class="string">'Root Locus - PID Control'</span>)
axis([ -300 100 -200 200])
sgrid(.5, 0)
sigrid(100)
</pre><img class="figure"vspace="5" hspace="5" src="Content/MotorPosition/Control/RootLocus/html/MotorPosition_ControlRootLocus_06.png" alt=""> <p>Even though the one open-loop zero was canceled, the other open-loop zero remains in the closed-loop transfer function and
         cannot be neglected. The effect of an additional zero (if there is no cancellation) is in general to speed up the response
         and add overshoot. Therefore, we have to be conservative in picking where on the root locus we want the closed-loop poles
         to lie.
      </p>
      <h2>Determining gain using rlocfind command<a name="22"></a></h2>
      <p>If you recall, we need the settling time and the overshoot to be as small as possible, particularly because of the effect
         of the extra zero. Large damping corresponds to points on the root locus near the real axis. A fast response corresponds to
         points on the root locus far to the left of the imaginary axis. To find the gain corresponding to a point on the root locus,
         we can use the <tt>rlocfind</tt> command. Specifically, enter the command <tt>[k,poles] = rlocfind(rsys_ol)</tt> in the MATLAB command window.
      </p>
      <p>Then go to the plot and select a point on the root locus on left side of the loop, close to the real axis as shown below with
         the small <tt>+</tt> marks. This will ensure that the response will be nearly as fast as possible with minimal overshoot. These pole locations
         indicate that the response would have almost no overshoot if it were a canonical second-order system. Recall, however, that
         the presence of the zero will add some overshoot.
      </p>
      <p><img class="figure"vspace="5" hspace="5" src="Content/MotorPosition/Control/RootLocus/figures/Figure3.png" alt=""> </p>
      <p>After doing this, you should see the following output in the MATLAB command window.</p>
      <p>
         </p><pre class="codeoutput">Select a point in the graphics window
         </p>
         selected_point =
         </p>
         -1.3744e+002 +1.3043e+001i
         </p>
         </p>
         k =
         </p>
         0.1308
         </p>
         </p>
         poles =
         </p>
         1.0e+002 *
         </p>
         -1.3874 + 0.1323i
         -1.3874 - 0.1323i
         </pre>
         
      </p>
      <p>Note that the values returned in your MATLAB command window may not be exactly the same, but should at least have the same
         order of magnitude. You can also get the step response plots for the reference and disturbance with this specific controller
         and loop gain by executing the following code in the command window. These commands should produce the plots shown below where
         the annotations to the figures are added by choosing <b>Characteristics</b> from the right-click menu of each of the plots.
      </p>
      <p>
         </p><pre class="codeinput">sys_cl = feedback(k*rsys_ol,1);
         t = 0:0.0001:0.1;
         step(sys_cl, t)
         grid
         ylabel(<span class="string">'Position, \theta (radians)'</span>)
         title(<span class="string">'Response to a Step Reference with PID Control'</span>)
         </pre>
         
      </p>
      <p><img class="figure"vspace="5" hspace="5" src="Content/MotorPosition/Control/RootLocus/figures/step_ref.png" alt=""> </p>
      <p>
         </p><pre class="codeinput">dist_cl = feedback(P_motor,k*C);
         figure;step(dist_cl, t)
         grid
         ylabel(<span class="string">'Position, \theta (radians)'</span>)
         title(<span class="string">'Response to a Step Disturbance with PID Control'</span>)
         </pre>
         
      </p>
      <p><img class="figure"vspace="5" hspace="5" src="Content/MotorPosition/Control/RootLocus/figures/step_dist.png" alt=""> </p>
      <p>From the above, you can see that in response to a step reference the system has an overshoot of approximately 14%, a settling
         time just under 0.04 seconds, and no steady-state error. Also, the response to a step disturbance reaches a steady-state value
         of zero. Therefore, all of the design requirements have been met.
      </p>
      <p>In this example we placed the zeros of our compensator in order to reshape the root locus so that the closed-loop poles could
         be placed in the region of the complex plane that would achieve our given design requirements. It is in general helpful to
         understand the principles of how the root locus is drawn, however, MATLAB can be very helpful in refining the design and verifying
         the resulting performance.
      </p>
      <p class="footer"><br>
         Published with MATLAB&reg; 7.14<br></p>
   </div>
</div>
<!--
##### SOURCE BEGIN #####
%% DC Motor Position: Root Locus Controller Design
%
% Key MATLAB commands used in this tutorial are:
% <http://www.mathworks.com/help/toolbox/control/ref/tf.html |tf|> , 
% <http://www.mathworks.com/help/toolbox/control/ref/rlocus.html |rlocus|> ,
% <http://www.mathworks.com/help/toolbox/control/ref/sgrid.html |sgrid|> ,
% <http://www.mathworks.com/help/toolbox/control/ref/pole.html |pole|> , 
% <http://www.mathworks.com/help/toolbox/control/ref/minreal.html |minreal|> , 
% <http://www.mathworks.com/help/toolbox/control/ref/feedback.html |feedback|> ,
% <http://www.mathworks.com/help/toolbox/control/ref/step.html |step|>
%
%% 
% From the main problem, the open-loop transfer function of the DC Motor is
% given as follows.
% 
% $$ P(s) = \frac {\Theta (s)}{V(s)} = \frac{K}{s ( (Js + b)(Ls + R) + K^2 )} \qquad [ \frac{rad}{V}  ] $$
%
% The structure of the control system has the form shown in the figure below. 
%
% <<Content/MotorPosition/Control/RootLocus/figures/feedback_motorp.png>>
%
%%
% For the original problem setup and the derivation of the above equations,
% please refer to the
% < ?example=MotorPosition&section=SystemModeling
% DC Motor Position: System Modeling> page. 
%
% With a 1-radian step reference, the design criteria are the following.
%
% * Settling time less than 0.040 seconds
% * Overshoot less than 16%
% * No steady-state error, even in the presence of a step disturbance input
%%
% Now let's design a controller using the *root locus* method.
%
% Create a new < ?aux=Extras_Mfile
% m-file> and type in the following commands (refer to main
% problem for the details of getting these commands). 

J = 3.2284E-6;
b = 3.5077E-6;
K = 0.0274;
R = 4;
L = 2.75E-6;
s = tf('s');
P_motor = K/(s*((J*s+b)*(L*s+R)+K^2));

%% Drawing the open-loop root locus
% The main idea of root locus design is to predict the closed-loop response
% from the root locus plot which depicts possible closed-loop pole
% locations and is drawn from the open-loop transfer function.
% Then by adding zeros and/or poles via the controller, the root locus
% can be modified in order to achieve a desired closed-loop response. 
% Let's first view the
% root locus for the plant. Add the following commands to the end of your
% m-file and run it in the MATLAB command window to generate a plot like
% the one shown below. 
%%
rlocus(P_motor)
title('Root Locus - P Control')
sgrid(.5, 0)
sigrid(100)

%%
% The commands |sgrid| and |sigrid| are < ?aux=Extras_Function
% functions> that mark regions of the 
% complex plane corresponding to certain parameters. |sgrid| is a function in
% the Control System Toolbox; however, to use < ?aux=Extras_sigrid
% sigrid> you will have to download it 
% <Content/MotorPosition/Control/RootLocus/sigrid.m here>. The variables in the |sgrid| command are the
% damping ratio (_zeta_ = 0.5) and the natural frequency (_Wn_ = 0). The
% variable in the |sigrid| command is the _sigma_ term. The _zeta_ and
% _sigma_ used above correspond to an overshoot of 16% and a settling time
% of 0.040 seconds, respectively, for a canonical second-order system. Even
% though our motor transfer function is third order, it will be explained
% that these second-order based definitions will work well. No value is
% given for _Wn_ since we have no requirement on rise time.  
%
% From the above figure, the two open-loop poles near the origin cannot be 
% distinguished because the scale of the axes is set to show the third pole
% which is much farther to the left than the other two poles. The MATLAB
% command |pole| can be employed to determine the exact values of the
% open-loop poles.  

poles = pole(P_motor)

%%
% The open-loop pole located very far to the left (further than -1e6) does
% not affect the closed-loop dynamics unless very large gains are used.
% These large gains place two of the closed-loop poles in the right-half
% complex _s_-plane where the system becomes unstable. Since we will not
% use gains that will make the closed-loop system unstable, we can neglect
% this pole by performing a model reduction. 

%% Model reduction
% In general, the real part of a pole indicates how quickly the transient
% portion of the corresponding mode decays to zero (assuming negative real
% part). Therefore, if you have a transfer function which has one (or more)
% poles much farther to the left in the complex plane (more negative) than
% the other poles, their effect on the dynamic response will be hidden by
% the slower, more dominant poles. In the case of our motor position
% example, the transient closed-loop response for small gains will not be
% affected much by the open-loop pole at -1.45e6. The correct way to neglect this
% pole in order to maintain its steady-state contribution is to keep the 
% DC gain of the transfer function the same, as follows:     

%%
% 
% $$  H(s) = \frac{G(s)}{s/p + 1} \approx G(s) \textrm{ for } s \ll p $$
%

%%
% As shown above, the poles of the open-loop transfer function can be
% identified using the MATLAB command |pole|. The two poles that dominate
% are difficult to identify from above because of the scientific notation,
% but they can be seen more clearly by recognizing that they are the first
% and third elements of the resulting vector which we have named |poles|. 

poles(1), poles(3)

%%
% We would then like to construct the reduced transfer function to neglect
% the pole at 1.45e-6 without affecting the steady-state behavior of the
% system. This can be accomplished with the MATLAB command |minreal|. Add
% the following commands to your m-file and re-run.

poles = pole(P_motor);
rP_motor = minreal(P_motor*(s/max(abs(poles)) + 1))

%%
% You can then check that the other poles have not been affected by
% again using the |pole| command as shown below.

pole(rP_motor)

%%
% Now we can draw the root locus of the reduced system. Add the following
% commands to the end of your m-file and run it in the command window.
      
rlocus(rP_motor)
title('Root Locus - P Control')
axis([ -300 100 -200 200])
sgrid(.5, 0)
sigrid(100)

%%
% If you examined the original root locus near the origin, it would closely
% approximate the locus of the reduced transfer function shown above. We
% can see from this new plot that the closed-loop poles are never fast
% enough to meet the settling time requirement (that is, they never move to
% the left of the _sigma_ = 100 vertical line). Also, recall that we need
% an integrator in the controller (not just in the system) to remove the
% steady-state error due to a constant disturbance.   
%
%% Integral control
% Now, let's try using integral control to remove the steady-state error
% due to a constant disturbance. Modify your m-file such that it appears
% like the following. Note that this adds a 1 / _s_ term to the forward path
% of the system. Run this m-file and you will obtain a plot like the one
% shown below. 

C = 1/s;
rlocus(C*rP_motor)
title('Root Locus - I Control')
axis([ -300 100 -200 200])
sgrid(.5, 0)
sigrid(100)

%%
% From this root locus we can see that the closed-loop system under
% integral control is never stable, therefore, a different controller must
% be employed.

%% PI control
%
% Now, let's modify the integral controller to a PI controller. Using PI
% instead of I control adds a zero to the open-loop system. We'll place
% this zero at _s_ = -20. The zero must lie between the open-loop poles of
% the system in this case so that the closed-loop system will be stable.
% Change the lines defining the controller in your m-file to the following.
% Re-run your m-file and you will obtain a plot like the one shown below.

C = (s + 20) / s;
rlocus(C*rP_motor)
title('Root Locus - PI Control')
axis([ -300 100 -200 200])
sgrid(.5, 0)
sigrid(100)

%%
% We have managed to stabilize the system and achieve zero steady-state error
% to a constant disturbance, but the system is still not fast enough.

%% PID control
%
% In order to pull the root locus further to the left, to make it faster,
% we need to place a second open-loop zero, resulting in a PID controller. 
% After some experimentation, we place the two PID zeros at _s_ = -60 and
% _s_ = -70. Change the lines defining the controller in your m-file to the
% following. Re-run your m-file and you will generate a plot like the one shown below.  

C = (s + 60)*(s + 70) / s;
rlocus(C*rP_motor)
title('Root Locus - PID Control')
axis([ -300 100 -200 200])
sgrid(.5, 0)
sigrid(100)

%%
% Now, we can see that two of the closed-loop poles can be placed well within
% both the settling time and percent overshoot requirements. The third
% closed-loop pole moves from the open-loop pole at _s_ = -59.2 to the
% open-loop zero at _s_ = -60. This closed-loop pole nearly cancels with the zero 
% (which remains in the closed-loop transfer function) because they are so
% close together. Therefore, we can neglect its effect.  Let's reduce our
% new model again by performing the zero-pole cancelation using the
% *minreal* command. We pass 0.1 as a tolerance parameter as follows. The
% root locus for this further reduced system with controller is shown
% below. Note how closely it resembles the root locus without the pole-zero
% cancelation.

rsys_ol = minreal(C*rP_motor, 0.1);
rlocus(rsys_ol)
title('Root Locus - PID Control')
axis([ -300 100 -200 200])
sgrid(.5, 0)
sigrid(100)

%%
% Even though the one open-loop zero was canceled, the other open-loop zero
% remains in the closed-loop transfer function and cannot be neglected. The
% effect of an additional zero (if there is no cancellation) is in general
% to speed up the response and add overshoot. Therefore, we have to be
% conservative in picking where on the root locus we want the closed-loop
% poles to lie. 

%% Determining gain using rlocfind command
%
% If you recall, we need the settling time and the overshoot to be as small
% as possible, particularly because of the effect of the extra zero. Large
% damping corresponds to points on the root locus near the real axis. A
% fast response corresponds to points on the root locus far to the left of
% the imaginary axis. To find the gain corresponding to a point on the root
% locus, we can use the |rlocfind| command. Specifically, enter the command
% |[k,poles] = rlocfind(rsys_ol)| in the MATLAB command window.
%
% Then go to the plot and select a point on the root locus on left side of
% the loop, close to the real axis as shown below with the small |+| marks. 
% This will ensure that the response will be nearly as fast as possible
% with minimal overshoot. These pole locations indicate that the response
% would have almost no overshoot if it were a canonical second-order
% system. Recall, however, that the presence of the zero will add 
% some overshoot.  
%
% <<Content/MotorPosition/Control/RootLocus/figures/Figure3.png>>
%
%%
% After doing this, you should see the following output in the MATLAB
% command window. 
%%
% <html>
% </p><pre class="codeoutput">Select a point in the graphics window
% </p>
% selected_point =
% </p>
%  -1.3744e+002 +1.3043e+001i
% </p>
% </p>
% k =
% </p>
%    0.1308
% </p>
% </p>
% poles =
% </p>
%   1.0e+002 *
% </p>
%  -1.3874 + 0.1323i
%  -1.3874 - 0.1323i
% </pre>
% </html>
%%
% Note that the values returned in your MATLAB command window may not be
% exactly the same, but should at least have the same order of magnitude.  
% You can also get the step response plots for the reference and
% disturbance with this specific controller and loop gain by executing the
% following code in the command window. These commands should produce the
% plots shown below where the annotations to the figures are added by
% choosing *Characteristics* from the right-click menu of each of the plots.
%%
% <html>
% </p><pre class="codeinput">sys_cl = feedback(k*rsys_ol,1);
% t = 0:0.0001:0.1;
% step(sys_cl, t)
% grid
% ylabel(<span class="string">'Position, \theta (radians)'</span>)
% title(<span class="string">'Response to a Step Reference with PID Control'</span>)
% </pre>
% </html>
%
%%
%
% <<Content/MotorPosition/Control/RootLocus/figures/step_ref.png>>
%
%%
% <html>
% </p><pre class="codeinput">dist_cl = feedback(P_motor,k*C);
% figure;step(dist_cl, t)
% grid
% ylabel(<span class="string">'Position, \theta (radians)'</span>)
% title(<span class="string">'Response to a Step Disturbance with PID Control'</span>)
% </pre>
% </html>
%%
%
% <<Content/MotorPosition/Control/RootLocus/figures/step_dist.png>>
%
%%
% From the above, you can see that in response to a step reference the
% system has an overshoot of approximately 14%, a 
% settling time just under 0.04 seconds, and no steady-state error. Also,
% the response to a step disturbance reaches a steady-state value of zero.
% Therefore, all of the design requirements have been met. 
%
% In this example we placed the zeros of our compensator in order to
% reshape the root locus so that the closed-loop poles could be placed in
% the region of the complex plane that would achieve our given design
% requirements. It is in general helpful to understand the principles of
% how the root locus is drawn, however, MATLAB can be very helpful in
% refining the design and verifying the resulting performance.
##### SOURCE END #####
-->				</div>
				
				<div id="left">

					<ul class="section">
						<li class="heading" id="System">SYSTEM<img class="section_heading_arrow" src="Images/section_heading_arrow.png"/></li>
						<li class="item" id="SystemModeling"><a href="index9ba6.html?example=MotorPosition&amp;section=SystemModeling">MODELING<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
						<li class="item" id="SystemAnalysis"><a href="indexb7ed.html?example=MotorPosition&amp;section=SystemAnalysis">ANALYSIS<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
					</ul>
					
					<div class="section_break"></div>

					<ul class="section">
						<li class="heading" id="Control">CONTROL<img class="section_heading_arrow" src="Images/section_heading_arrow.png"/></li>
						<li class="item" id="ControlPID"><a href="indexe534.html?example=MotorPosition&amp;section=ControlPID">PID<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
						<li class="item" id="ControlRootLocus"><a href="index3c83.html?example=MotorPosition&amp;section=ControlRootLocus">ROOT&nbsp;LOCUS<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
						<li class="item" id="ControlFrequency"><a href="index1ae7.html?example=MotorPosition&amp;section=ControlFrequency">FREQUENCY<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
						<li class="item" id="ControlStateSpace"><a href="indexc79c.html?example=MotorPosition&amp;section=ControlStateSpace">STATE-SPACE<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
						<li class="item" id="ControlDigital"><a href="index7d62.html?example=MotorPosition&amp;section=ControlDigital">DIGITAL<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
					</ul>
					
					<div class="section_break"></div>

					<ul class="section">
						<li class="heading" id="Simulink">SIMULINK<img class="section_heading_arrow" src="Images/section_heading_arrow.png"/></li>
						<li class="item" id="SimulinkModeling"><a href="index6d09.html?example=MotorPosition&amp;section=SimulinkModeling">MODELING<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
						<li class="item" id="SimulinkControl"><a href="index4c9e.html?example=MotorPosition&amp;section=SimulinkControl">CONTROL<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
					</ul>
		
				</div>
			
				<div style="clear:both"></div>
				
				<div id="bottombar"><span style="color:#FF5500;font-weight:bold">.</div>
				
			</div>
			
		</div>
	
		<script type="text/javascript" src="script.js"></script>
						
	</body>
	

<!-- Mirrored from ctms.engin.umich.edu/CTMS/index.php?example=MotorPosition&section=ControlRootLocus by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 19 Jun 2014 21:10:43 GMT -->
</html>

	lRootLocus by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 19 Jun 2014 21:10:43 GMT -->
</html>

	
		<script type="text/javascript" src="script.js"></script>
						
	</body>
	

<!-- Mirrored from ctms.engin.umich.edu/CTMS/index.php?example=MotorPosition&section=ControlRootLocus by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 19 Jun 2014 21:10:43 GMT -->
</html>

	lRootLocus by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 19 Jun 2014 21:10:43 GMT -->
</html>

	pier/3.x [XR&CO'2014], Thu, 19 Jun 2014 21:10:43 GMT -->
</html>

	lRootLocus by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 19 Jun 2014 21:10:43 GMT -->
</html>

	