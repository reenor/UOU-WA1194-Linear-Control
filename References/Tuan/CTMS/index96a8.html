<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

	
<!-- Mirrored from ctms.engin.umich.edu/CTMS/index.php?example=InvertedPendulum&section=ControlStateSpace by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 19 Jun 2014 21:12:12 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>

		<script type="text/javascript" src="jquery.js"></script>
					
		<link rel='stylesheet' type='text/css' href='style.css' />
		<script type="text/javascript">
	
			var example = "InvertedPendulum"; 
			var section = "ControlStateSpace"; 
			var aux = ""; 
			var effects = Boolean(1); 
			var tips = Boolean(1); 
			$.fx.off = !effects;
			
			$(document).keydown(function(e){
				if (!$("#search_field").is(":focus")){
					if (e.keyCode == 39) { 
						window.location = "index5759.html?example=InvertedPendulum&amp;section=ControlDigital";
					}
					if (e.keyCode == 37) { 
						window.history.back()
					}
				}
			});		
			
		</script>
			
		<meta http-equiv="Content-Type" Content="text/html; charset=utf-8" />
		<meta http-equiv="PRAGMA" Content="NO-CACHE" />
		
		<title>Control Tutorials for MATLAB and Simulink - Inverted Pendulum: State-Space Methods for Controller Design</title>
			
	</head>

	<body>
	
		
		<div id="container">
		
			<form id="search_form"><input id="search_field" type="text" name="q" placeholder="Search Control Tutorials"/></form>
			<form class="option_form" method="post" onclick="submit()"><div>Effects</div><input type="hidden" name="effects" value="0"/><input type="checkbox" name="effects" value="1" checked='true' /></form>
			<form class="option_form" method="post" onclick="submit()"><div>Tips</div><input type="hidden" name="tips" value="0"/><input type="checkbox" name="tips" value="1" checked='true' /></form>	
				
			<div style="clear:both"></div>
		
			<div id="header">
		
				

				
				
				<div id="menu_container">
				
					<ul class="menu">
						<li class="heading" id="Tips"><a href="index80e7.html?aux=Extras_Tips">TIPS</a></li>
						<div class="collapse"><div class="expand">
						</div></div>
					</ul>
				
					<ul class="menu">
						<li class="heading" id="About"><a>ABOUT</a></li>
						<div class="collapse"><div class="expand">
							<li class="item" id="About_Tutorials"><a href="index64fe.html?aux=About_Tutorials">Tutorials</a></li>
							<li class="item" id="About_Contact"><a href="mailto:ControlTutorialsMatlabSimulink@gmail.com">Contact</a></li>
						</div></div>
					</ul>
					
					<ul class="menu">
						<li class="heading" id="Basics"><a>BASICS</a></li>
						<div class="collapse"><div class="expand">
							<li class="item" id="Basics_Matlab"><a href="index87b6.html?aux=Basics_Matlab">MATLAB</a></li>
							<li class="item" id="Basics_Simulink"><a href="indexe9ea.html?aux=Basics_Simulink">Simulink</a></li>
						</div></div>
					</ul>
					
					<ul class="menu">
						<li class="heading" id="Index"><a>INDEX</a></li>
						<div class="collapse"><div class="expand">
							<li class="item" id="Index_Tutorials"><a href="index5e52.html?aux=Index_Tutorials">Tutorials</a></li>
							<li class="item" id="Index_Commands"><a href="index111e.html?aux=Index_Commands">Commands</a></li>
							<li class="item" id="Index_Animations"><a href="indexc3c5.html?aux=Index_Animations">Animations</a></li>
							<li class="item" id="Index_Extras"><a href="indexb290.html?aux=Index_Extras">Extras</a></li>
						</div></div>
					</ul>
									
					<ul class="menu">
						<li class="heading" id="Next"><a href="index5759.html?example=InvertedPendulum&amp;section=ControlDigital">NEXT&nbsp;&#x25BA;</a></li>
						<div class="collapse"><div class="expand">
						</div></div>
					</ul>
											
				</div>

			</div>
			
			<div id="body_container">
			
				<div id="gradient_container"></div>
			
				<div id="top">
				
					<a href="index1304.html?aux=Home"><img id="CTMS_logo" src="Images/CTMS_logo.png"></a>
				
					<ul class="example">
					
						<li class="item" id="Introduction"><a href="index9b18.html?example=Introduction&amp;section=ControlStateSpace"><img class="icon" src="Images/Introduction_Icon.png"><div class="tab">INTRODUCTION</div></a></li>
						<li class="item" id="CruiseControl"><a href="index1502.html?example=CruiseControl&amp;section=ControlStateSpace"><img class="icon" src="Images/CruiseControl_Icon.png"><div class="tab">CRUISE&nbsp;CONTROL</div></a></li>
						<li class="item" id="MotorSpeed"><a href="indexd22e.html?example=MotorSpeed&amp;section=ControlStateSpace"><img class="icon" src="Images/MotorSpeed_Icon.png"><div class="tab">MOTOR&nbsp;SPEED</div></a></li>
						<li class="item" id="MotorPosition"><a href="indexc79c.html?example=MotorPosition&amp;section=ControlStateSpace"><img class="icon" src="Images/MotorPosition_Icon.png"><div class="tab">MOTOR&nbsp;POSITION</div></a></li>
						<li class="item" id="Suspension"><a href="index7de2.html?example=Suspension&amp;section=ControlStateSpace"><img class="icon" src="Images/Suspension_Icon.png"><div class="tab">SUSPENSION</div></a></li>
						<li class="item" id="InvertedPendulum"><a href="index96a8.html?example=InvertedPendulum&amp;section=ControlStateSpace"><img class="icon" src="Images/InvertedPendulum_Icon.png"><div class="tab">INVERTED&nbsp;PENDULUM</div></a></li>
						<li class="item" id="AircraftPitch"><a href="indexcff8.html?example=AircraftPitch&amp;section=ControlStateSpace"><img class="icon" src="Images/AircraftPitch_Icon.png"><div class="tab">AIRCRAFT&nbsp;PITCH</div></a></li>
						<li class="item" id="BallBeam"><a href="indexfa3e.html?example=BallBeam&amp;section=ControlStateSpace"><img class="icon" src="Images/BallBeam_Icon.png"><div class="tab">BALL&nbsp;&amp;&nbsp;BEAM</div></a></li>
					
					</ul> 
		
				</div>
				
				<div id="content_container">
					<div class="content">
   <div class="content_fx">
      <h1>Inverted Pendulum: State-Space Methods for Controller Design</h1>
      <!--introduction-->
      <p>Key MATLAB commands used in this tutorial are: <a href="http://www.mathworks.com/help/toolbox/control/ref/ss.html"><tt>ss</tt></a> , <a href="http://www.mathworks.com/help/techdoc/ref/eig.html"><tt>eig</tt></a> , <a href="http://www.mathworks.com/help/toolbox/control/ref/lsim.html"><tt>lsim</tt></a> , <a href="http://www.mathworks.com/help/toolbox/control/ref/lqr.html"><tt>lqr</tt></a> , <a href="http://www.mathworks.com/help/toolbox/control/ref/ctrb.html"><tt>ctrb</tt></a> , <a href="http://www.mathworks.com/help/toolbox/rf/plotyy.html"><tt>plotyy</tt></a> , <a href="http://www.mathworks.com/help/toolbox/control/ref/obsv.html"><tt>obsv</tt></a> , <a href="http://www.mathworks.com/help/toolbox/control/ref/place.html"><tt>place</tt></a></p>
      <!--/introduction-->
      <h2>Contents</h2>
      <div>
         <ul>
            <li><a href="#4">Open-loop poles</a></li>
            <li><a href="#6">Linear Quadratic Regulation (LQR)</a></li>
            <li><a href="#11">Adding precompensation</a></li>
            <li><a href="#14">Observer-based control</a></li>
         </ul>
      </div>
      <p>From the main problem, the dynamic equations of the inverted pendulum system in state-space form are the following:</p>
      <p><span class="eqn_num">(1)</span><img class="display_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq35070.png" alt="$$&#xA;\left[{\begin{array}{c}&#xA;  \dot{x} \\ \ddot{x} \\ \dot{\phi} \\ \ddot{\phi}&#xA;\end{array}}\right] =&#xA;\left[{\begin{array}{cccc}&#xA;  0 &amp; 1 &amp; 0 &amp; 0 \\&#xA;  0 &amp; -0.1818 &amp; 2.6727 &amp; 0 \\&#xA;  0 &amp; 0 &amp; 0 &amp; 1 \\&#xA;  0 &amp; -0.4545 &amp; 31.1818 &amp; 0&#xA;\end{array}}\right]&#xA;\left[{\begin{array}{c}&#xA;  x \\ \dot{x} \\ \phi \\ \dot{\phi}&#xA;\end{array}}\right] +&#xA;\left[{\begin{array}{c}&#xA;  0 \\ 1.8182 \\ 0 \\ 4.5455&#xA;\end{array}}\right]u&#xA;$$"></p>
      <p><span class="eqn_num">(2)</span><img class="display_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq85452.png" alt="$$&#xA;{\bf y} = \left[{\begin{array}{cccc}&#xA;  1 &amp; 0 &amp; 0 &amp; 0 \\&#xA;  0 &amp; 0 &amp; 1 &amp; 0&#xA;\end{array}}\right]&#xA;\left[{\begin{array}{c}&#xA;  x \\ \dot{x} \\ \phi \\ \dot{\phi}&#xA;\end{array}}\right] +&#xA;\left[{\begin{array}{c}&#xA;  0 \\ 0&#xA;\end{array}}\right]u&#xA;$$"></p>
      <p>To see how this problem was originally set up and the system equations were derived, consult the <a href="indexdeb1.html?example=InvertedPendulum&amp;section=SystemModeling">Inverted Pendulum: System Modeling</a> page. For this problem the outputs are the cart's displacement (<img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq43551.png" alt="$x$"> in meters) and the pendulum angle (<img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq26509.png" alt="$\phi$"> in radians) where <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq26509.png" alt="$\phi$"> represents the deviation of the pedulum's position from equilibrium, that is, <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq86993.png" alt="$\theta = \pi + \phi$">.
      </p>
      <p>The design criteria for this system for a 0.2-m step in desired cart position <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq43551.png" alt="$x$"> are as follows:
      </p>
      <div>
         <ul>
            <li>Settling time for <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq43551.png" alt="$x$"> and <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq49435.png" alt="$\theta$"> of less than 5 seconds
            </li>
            <li>Rise time for <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq43551.png" alt="$x$"> of less than 0.5 seconds
            </li>
            <li>Pendulum angle <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq49435.png" alt="$\theta$"> never more than 20 degrees (0.35 radians) from the vertical
            </li>
            <li>Steady-state error of less than 2% for <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq43551.png" alt="$x$"> and <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq49435.png" alt="$\theta$"></li>
         </ul>
      </div>
      <p>As you may have noticed if you went through some of the other inverted pendulum examples, the design criteria for this example
         are different. In the other examples we were attemping to keep the pendulum vertical in response to an impulsive disturbance
         force applied to the cart. We did not attempt to control the cart's position. In this example, we are attempting to keep the
         pendulum vertical while controlling the cart's position to move 0.2 meters to the right. A state-space design approach is
         well suited to the control of multiple outputs as we have here.
      </p>
      <p>This problem can be solved using full-state feedback. The schematic of this type of control system is shown below where <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq07190.png" alt="$\mathbf{K}$"> is a matrix of control gains. Note that here we feedback all of the system's states, rather than using the system's outputs
         for feedback.
      </p>
      <p><img class="figure"vspace="5" hspace="5" src="Content/InvertedPendulum/Control/StateSpace/figures/statefeedback_pend2.png" alt=""> </p>
      <h2>Open-loop poles<a name="4"></a></h2>
      <p>In this problem, <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq25861.png" alt="$r$"> represents the step command of the cart's position. The 4 states represent the position and velocity of the cart and the
         angle and angular velocity of the pendulum.  The output <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq49998.png" alt="$\mathbf{y}$"> contains both the position of the cart and the angle of the pendulum.  We want to design a controller so that when a step
         reference is given to the system, the pendulum should be displaced, but eventually return to zero (i.e. vertical) and the
         cart should move to its new commanded position. To view the system's open-loop response please refer to the <a href="indexce00.html?example=InvertedPendulum&amp;section=SystemAnalysis">Inverted Pendulum: System Analysis</a> page.
      </p>
      <p>The first step in designing a full-state feedback controller is to determine the open-loop poles of the system. Enter the
         following lines of code into an <a href="indexd754.html?aux=Extras_Mfile">m-file</a>. After execution in the MATLAB command window, the output will list the open-loop poles (eigenvalues of <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq53374.png" alt="$\mathbf{A}$">) as shown below.
      </p><pre class="codeinput">M = 0.5;
m = 0.2;
b = 0.1;
I = 0.006;
g = 9.8;
l = 0.3;

p = I*(M+m)+M*m*l^2; <span class="comment">%denominator for the A and B matrices</span>

A = [0      1              0           0;
     0 -(I+m*l^2)*b/p  (m^2*g*l^2)/p   0;
     0      0              0           1;
     0 -(m*l*b)/p       m*g*l*(M+m)/p  0];
B = [     0;
     (I+m*l^2)/p;
          0;
        m*l/p];
C = [1 0 0 0;
     0 0 1 0];
D = [0;
     0];

states = {<span class="string">'x'</span> <span class="string">'x_dot'</span> <span class="string">'phi'</span> <span class="string">'phi_dot'</span>};
inputs = {<span class="string">'u'</span>};
outputs = {<span class="string">'x'</span>; <span class="string">'phi'</span>};

sys_ss = ss(A,B,C,D,<span class="string">'statename'</span>,states,<span class="string">'inputname'</span>,inputs,<span class="string">'outputname'</span>,outputs);

poles = eig(A)
</pre><pre class="codeoutput">poles =
         0
   -5.6041
   -0.1428
    5.5651
</pre><p>As you can see, there is one right-half plane pole at 5.5651. This should confirm your intuition that the system is unstable
         in open loop.
      </p>
      <h2>Linear Quadratic Regulation (LQR)<a name="6"></a></h2>
      <p>The next step in the design process is to find the vector of state-feedback control gains <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq07190.png" alt="$\mathbf{K}$"> assuming that we have access (i.e. can measure) all four of the state variables. This can be accomplished in a number of
         ways.  If you know the desired closed-loop pole locations, you can use the MATLAB commands <tt>place</tt> or <tt>acker</tt>. Another option is to use the <tt>lqr</tt> command which returns the optimal controller gain assuming a linear plant, quadratic cost function, and reference equal to
         zero (consult your textbook for more details).
      </p>
      <p>Before we design our controller, we will first verify that the system is <b>controllable</b>. Satisfaction of this property means that we can drive the state of the system anywhere we like in finite time (under the
         physical constraints of the system). For the system to be completely state controllable, the controllability matrix must have
         rank <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq25947.png" alt="$n$"> where the rank of a matrix is the number of independent rows (or columns). The controllability matrix of the system takes
         the form shown below. The number <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq25947.png" alt="$n$"> corresponds to the number of state variables of the system. Adding additional terms to the controllability matrix with higher
         powers of the matrix <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq53374.png" alt="$\mathbf{A}$"> will not increase the rank of the controllability matrix since these additional terms will just be linear combinations of
         the earlier terms.
      </p>
      <p><span class="eqn_num">(3)</span><img class="display_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq76126.png" alt="$$ \mathcal{C} = [A|AB|A^2B|\cdots|A^{n-1}B] $$"></p>
      <p>Since our controllability matrix is 4x4, the rank of the matrix must be 4. We will use the MATLAB command <tt>ctrb</tt> to generate the controllability matrix and the MATLAB command <tt>rank</tt> to test the rank of the matrix. Adding the following additional commands to your m-file and running in the MATLAB command
         window will produce the following output.
      </p><pre class="codeinput">co = ctrb(sys_ss);
controllability = rank(co)
</pre><pre class="codeoutput">controllability =
     4
</pre><p>Therefore, we have verified that our system is controllable and thus we should  be able to design a controller that achieves
         the given requirements. Specifically, we will use the <b>linear quadratic regulation</b> method for determining our state-feedback control gain matrix <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq07190.png" alt="$\mathbf{K}$">. The MATLAB function <tt>lqr</tt> allows you to choose two parameters, <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq28884.png" alt="$\mathbf{R}$"> and <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq26149.png" alt="$\mathbf{Q}$">, which will balance the relative importance of the control effort (<img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq35435.png" alt="$u$">) and error (deviation from 0), respectively, in the cost function that you are trying to optimize. The simplest case is to
         assume <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq37089.png" alt="$\mathbf{R}=1$">, and  <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq22834.png" alt="$\mathbf{Q = C'C}$">. The cost function corresponding to this <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq28884.png" alt="$\mathbf{R}$"> and <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq26149.png" alt="$\mathbf{Q}$"> places equal importance on the control and the state variables which are outputs (the pendulum's angle and the cart's position).
         Essentially, the lqr method allows for the control of both outputs.  In this case, it is pretty easy  to do.  The controller
         can be tuned by changing the nonzero elements in the <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq26149.png" alt="$\mathbf{Q}$"> matrix to achieve a desirable response. To observe the structure of <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq26149.png" alt="$\mathbf{Q}$">, enter the following into the MATLAB command window to see the output given below.
      </p><pre class="codeinput">Q = C'*C
</pre><pre class="codeoutput">Q =
     1     0     0     0
     0     0     0     0
     0     0     1     0
     0     0     0     0
</pre><p>The element in the (1,1) position of <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq26149.png" alt="$\mathbf{Q}$"> represents the weight on the cart's position and the element in the (3,3) position represents the weight on the pendulum's
         angle.  The input weighting <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq28884.png" alt="$\mathbf{R}$"> will remain at 1. Ultimately what matters is the relative value of <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq26149.png" alt="$\mathbf{Q}$"> and <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq28884.png" alt="$\mathbf{R}$">, not their absolute values. Now that we know how to interpret the <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq26149.png" alt="$\mathbf{Q}$"> matrix, we can experiment to find the <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq07190.png" alt="$\mathbf{K}$"> matrix that will give us a "good" controller.  We will go ahead and find the <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq07190.png" alt="$\mathbf{K}$"> matrix and plot the response all in one step so that changes can be made in the control and seen automatically in the response.
         Add the following commands to the end of your m-file and run in the MATLAB command window to get the following value for <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq07190.png" alt="$\mathbf{K}$"> and the response plot shown below.
      </p><pre class="codeinput">Q = C'*C;
R = 1;
K = lqr(A,B,Q,R)

Ac = [(A-B*K)];
Bc = [B];
Cc = [C];
Dc = [D];

states = {<span class="string">'x'</span> <span class="string">'x_dot'</span> <span class="string">'phi'</span> <span class="string">'phi_dot'</span>};
inputs = {<span class="string">'r'</span>};
outputs = {<span class="string">'x'</span>; <span class="string">'phi'</span>};

sys_cl = ss(Ac,Bc,Cc,Dc,<span class="string">'statename'</span>,states,<span class="string">'inputname'</span>,inputs,<span class="string">'outputname'</span>,outputs);

t = 0:0.01:5;
r =0.2*ones(size(t));
[y,t,x]=lsim(sys_cl,r,t);
[AX,H1,H2] = plotyy(t,y(:,1),t,y(:,2),<span class="string">'plot'</span>);
set(get(AX(1),<span class="string">'Ylabel'</span>),<span class="string">'String'</span>,<span class="string">'cart position (m)'</span>)
set(get(AX(2),<span class="string">'Ylabel'</span>),<span class="string">'String'</span>,<span class="string">'pendulum angle (radians)'</span>)
title(<span class="string">'Step Response with LQR Control'</span>)
</pre><pre class="codeoutput">K =
   -1.0000   -1.6567   18.6854    3.4594
</pre><img class="figure"vspace="5" hspace="5" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_01.png" alt=""> <p>The curve in green represents the pendulum's angle in radians, and the curve in blue represents the cart's position in meters.
         As you can see, this plot is not satisfactory. The pendulum and cart's overshoot appear fine, but their settling times need
         improvement and the cart's rise time needs to be reduced. As I'm sure you have noticed, the cart's final position is also
         not near the desired location but has in fact moved in the opposite direction. This error will be dealt with in the next section
         and right now we will focus on the settling and rise times. Go back to your m-file and change the <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq26149.png" alt="$\mathbf{Q}$"> matrix to see if you can get a better response. You will find that increasing the (1,1) and (3,3) elements makes the settling
         and rise times go down, and lowers the angle the pendulum moves. In other words, you are putting more weight on the errors
         at the cost of increased control effort <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq35435.png" alt="$u$">. Modifying your m-file so that the (1,1) element of <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq26149.png" alt="$\mathbf{Q}$"> is 5000 and the (3,3) element is 100, will produce the following value of <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq07190.png" alt="$\mathbf{K}$"> and the step response shown below.
      </p><pre class="codeinput">Q = C'*C;
Q(1,1) = 5000;
Q(3,3) = 100
R = 1;
K = lqr(A,B,Q,R)

Ac = [(A-B*K)];
Bc = [B];
Cc = [C];
Dc = [D];

states = {<span class="string">'x'</span> <span class="string">'x_dot'</span> <span class="string">'phi'</span> <span class="string">'phi_dot'</span>};
inputs = {<span class="string">'r'</span>};
outputs = {<span class="string">'x'</span>; <span class="string">'phi'</span>};

sys_cl = ss(Ac,Bc,Cc,Dc,<span class="string">'statename'</span>,states,<span class="string">'inputname'</span>,inputs,<span class="string">'outputname'</span>,outputs);

t = 0:0.01:5;
r =0.2*ones(size(t));
[y,t,x]=lsim(sys_cl,r,t);
[AX,H1,H2] = plotyy(t,y(:,1),t,y(:,2),<span class="string">'plot'</span>);
set(get(AX(1),<span class="string">'Ylabel'</span>),<span class="string">'String'</span>,<span class="string">'cart position (m)'</span>)
set(get(AX(2),<span class="string">'Ylabel'</span>),<span class="string">'String'</span>,<span class="string">'pendulum angle (radians)'</span>)
title(<span class="string">'Step Response with LQR Control'</span>)
</pre><pre class="codeoutput">Q =
        5000           0           0           0
           0           0           0           0
           0           0         100           0
           0           0           0           0
K =
  -70.7107  -37.8345  105.5298   20.9238
</pre><img class="figure"vspace="5" hspace="5" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_02.png" alt=""> <p>You may have noted that if you increased the values of the elements of <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq26149.png" alt="$\mathbf{Q}$"> even higher, you could improve the response even more. The reason this weighting was chosen was because it just satisfies
         the transient design requirements. Increasing the magnitude of <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq26149.png" alt="$\mathbf{Q}$"> more would make the tracking error smaller, but would require greater control force <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq35435.png" alt="$u$">. More control effort generally corresponds to greater cost (more energy, larger actuator, etc.).
      </p>
      <h2>Adding precompensation<a name="11"></a></h2>
      <p>The controller we have designed so far meets our transient requirements, but now we must address the steady-state error. In
         contrast to the other design methods, where we feedback the output and compare it to the reference input to compute an error,
         with a full-state feedback controller we are feeding back all of the states. We need to compute what the steady-state value
         of the states should be, multiply that by the chosen gain <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq07190.png" alt="$\mathbf{K}$">, and use a new value as our "reference" for computing the input. This can be done by adding a constant gain <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq94609.png" alt="$\bar{N}$"> after the reference. The schematic below shows this relationship:
      </p>
      <p><img class="figure"vspace="5" hspace="5" src="Content/InvertedPendulum/Control/StateSpace/figures/statefeedback_w_pre_pend.png" alt=""> </p>
      <p>We can find this <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq94609.png" alt="$\bar{N}$"> factor by employing the used-defined function <a href="index1f18.html?aux=Extras_rscale">rscale.m</a> as shown below. The <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq50346.png" alt="$\mathbf{C}$"> matrix is modified to reflect the fact that the reference is a command only on cart position.
      </p><pre class="codeinput">Cn = [1 0 0 0];
sys_ss = ss(A,B,Cn,0);
Nbar = rscale(sys_ss,K)
</pre><pre class="codeoutput">Nbar =
  -70.7107
</pre><p>Note that the function <tt>rscale.m</tt> is not a standard function in MATLAB. You will have to download it <a href="Content/InvertedPendulum/Control/StateSpace/rscale.m">here</a> and place it in your current directory. More information can be found here, <a href="index1f18.html?aux=Extras_rscale">Extras: rscale.m</a>. Now you can plot the step response by adding the above and following lines of code to your m-file and re-running at the
         command line.
      </p><pre class="codeinput">sys_cl = ss(Ac,Bc*Nbar,Cc,Dc,<span class="string">'statename'</span>,states,<span class="string">'inputname'</span>,inputs,<span class="string">'outputname'</span>,outputs);

t = 0:0.01:5;
r =0.2*ones(size(t));
[y,t,x]=lsim(sys_cl,r,t);
[AX,H1,H2] = plotyy(t,y(:,1),t,y(:,2),<span class="string">'plot'</span>);
set(get(AX(1),<span class="string">'Ylabel'</span>),<span class="string">'String'</span>,<span class="string">'cart position (m)'</span>)
set(get(AX(2),<span class="string">'Ylabel'</span>),<span class="string">'String'</span>,<span class="string">'pendulum angle (radians)'</span>)
title(<span class="string">'Step Response with Precompensation and LQR Control'</span>)
</pre><img class="figure"vspace="5" hspace="5" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_03.png" alt=""> <p>Now, the steady-state error is within our limits, the rise and settle times are met, and the pendulum's overshoot is within
         range of the design criteria.
      </p>
      <p>Note that the precompensator <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq94609.png" alt="$\bar{N}$"> employed above is calculated based on the model of the plant and further that the precompensator is located outside of the
         feedback loop. Therefore, if there are errors in the model (or unknown disturbances) the precompensator will not correct for
         them and there will be steady-state error. You may recall that the addition of integral control may also be used to eliminate
         steady-state error, even in the presence of model uncertainty and step disturbances. For an example of how to implement integral
         control in the state space setting, see the <a href="indexc79c.html?example=MotorPosition&amp;section=ControlStateSpace">Motor Position: State-Space Methods</a> example. The tradeoff with using integral control is that the error must first develop before it can be corrected for, therefore,
         the system may be slow to respond. The precompensator on the other hand is able to anticipitate the steady-state offset using
         knowledge of the plant model. A useful technique is to combine the precompensator with integral control to leverage the advantages
         of each approach.
      </p>
      <h2>Observer-based control<a name="14"></a></h2>
      <p>The response achieved above is good, but was based on the assumption of full-state feedback, which is not necessarily valid.
         To address the situation where not all state variables are measured, a state estimator must be designed. A schematic of state-feedback
         control with a full-state estimator is shown below, without the precompensator <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq94609.png" alt="$\bar{N}$">.
      </p>
      <p><img class="figure"vspace="5" hspace="5" src="Content/InvertedPendulum/Control/StateSpace/figures/observer_statefeedback_pend.png" alt=""> </p>
      <p>Before we design our estimator, we will first verify that our system is <b>observable</b>. The property of observability determines whether or not based on the measured outputs of the system we can estimate the
         state of the system. Similar to the process for verifying controllability, a system is observable if its observability matrix
         is full rank. The observability matrix is defined as follows.
      </p>
      <p><span class="eqn_num">(4)</span><img class="display_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq73816.png" alt="$$ \mathcal{O} =\left[\begin{array}{c} C \\ CA \\ CA^2 \\ \vdots \\ CA^{n-1}&#xA;\end{array} \right] $$"></p>
      <p>We can employ the MATLAB command <tt>obsv</tt> to contruct the observability matrix and the <tt>rank</tt> command to check its rank as shown below.
      </p><pre class="codeinput">ob = obsv(sys_ss);
observability = rank(ob)
</pre><pre class="codeoutput">observability =
     4
</pre><p>Since the observability matrix is 8x4 and has rank 4, it is full rank and our system is observable. The observability matrix
         in this case is not square since our system has two outputs. Note that if we could only measure the pendulum angle output,
         we would not be able to estimate the full state of the system. This can be verified by the fact that <tt>obsv(A,C(2,:))</tt> produces an observability matrix that is not full rank.
      </p>
      <p>Since we know that we can estimate our system state, we will now describe the process for designing a state estimator. Based
         on the above diagram, the dynamics of the state estimate are described by the following equation.
      </p>
      <p><span class="eqn_num">(5)</span><img class="display_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq61735.png" alt="$$ \dot{\hat{{\bf x}}} = A{\hat{\bf x}} + Bu + L({\bf y} - {\hat{\bf y}}) $$"></p>
      <p>The spirit of this equation is similar to that of closed-loop control in that last term is a correction based on feedback.
         Specifically, the last term corrects the state estimate based on the difference between the actual output <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq44020.png" alt="$y$"> and the estimated output <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq82859.png" alt="$\hat{y}$">. Now let's look at the dynamics of the error in the state estimate.
      </p>
      <p><span class="eqn_num">(6)</span><img class="display_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq69649.png" alt="$$ \dot{{\bf e}} = \dot{{\bf x}} - \dot{\hat{{\bf x}}} =&#xA;   (A{\bf x} + Bu) - (A{\hat{\bf x}} + Bu + L(C{\bf x} - C{\hat{\bf x}})) $$"></p>
      <p>Therefore, the state estimate error dynamics are described by</p>
      <p><span class="eqn_num">(7)</span><img class="display_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq68807.png" alt="$$ \dot{{\bf e}} = (A-LC){\bf e} $$"></p>
      <p>and the error will approach zero (<img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq50789.png" alt="$\hat{x}$"> will approach <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq43551.png" alt="$x$">) if the matrix <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq38229.png" alt="$\mathbf{A-LC}$"> is stable (has negative eigenvalues). As is with the case for control, the speed of convergence depends on the poles of the
         estimator (eigenvalues of <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq38229.png" alt="$\mathbf{A-LC}$">). Since we plan to use the state estimate as the input to our controller, we would like the state estimate to converge faster
         than is desired from our overall closed-loop system. That is, we would like the observer poles to be faster than the controller
         poles. A common guideline is to make the estimator poles 4-10 times faster than the slowest controller pole. Making the estimator
         poles too fast can be problematic if the measurement is corrupted by noise or there are errors in the sensor measurement in
         general.
      </p>
      <p>Based on this logic, we must first find the controller poles. To do this, copy the following code to the end of your m-file.
          If you employed the updated <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq26149.png" alt="$\mathbf{Q}$"> matrix, you should see the following poles in the MATLAB command window.
      </p><pre class="codeinput">poles = eig(Ac)
</pre><pre class="codeoutput">poles =
  -8.4910 + 7.9283i
  -8.4910 - 7.9283i
  -4.7592 + 0.8309i
  -4.7592 - 0.8309i
</pre><p>The slowest poles have real part equal to -4.7592, therefore, we will place our estimator poles at -40. Since the closed-loop
         estimator dynamics are determined by a matrix (<img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq38229.png" alt="$\mathbf{A-LC}$">) that has a similar form to the matrix that determines the dynamics of the state-feedback system (<img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq54141.png" alt="$\mathbf{A-BK}$">), we can use the same commands for finding the estimator gain <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq15477.png" alt="$\mathbf{L}$"> as we can for finding the state-feedback gain <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq07190.png" alt="$\mathbf{K}$">. Specifically, since taking the transpose of <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq38229.png" alt="$\mathbf{A-LC}$"> leaves the eigenvalues unchanged and produces a result <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq71090.png" alt="$\mathbf{A'-C'L'}$"> that exactly matches the form of <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq54141.png" alt="$\mathbf{A-BK}$">, we can use the <tt>acker</tt> or <tt>place</tt> commands. Recalling that the <tt>place</tt> command cannot place poles of multiplicity greater than one, we will place the observer poles as follows. Add the following
         commands to your m-file to calculate the <img class="inline_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq15477.png" alt="$\mathbf{L}$"> matrix and generate the output shown below.
      </p><pre class="codeinput">P = [-40 -41 -42 -43];
L = place(A',C',P)'
</pre><pre class="codeoutput">L =
   1.0e+03 *
    0.0826   -0.0010
    1.6992   -0.0402
   -0.0014    0.0832
   -0.0762    1.7604
</pre><p>We are using both outputs (the angle of the pendulum and the position of the cart) to design the observer.</p>
      <p>Now we will combine our state-feedback controller from before with our state estimator to get the full compensator. The resulting
         closed-loop system is described by the following matrix equations.
      </p>
      <p><span class="eqn_num">(8)</span><img class="display_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq57504.png" alt="$$&#xA;\left[{\begin{array}{c}&#xA;  \dot{{\bf x}} \\ \dot{\bf{e}}&#xA;\end{array}}\right] =&#xA;\left[{\begin{array}{cc}&#xA;  A-BK &amp; BK \\&#xA;  0 &amp; A-LC&#xA;\end{array}}\right]&#xA;\left[{\begin{array}{c}&#xA;  {\bf x} \\ {\bf e}&#xA;\end{array}}\right] +&#xA;\left[{\begin{array}{c}&#xA;  B \bar{N} \\ 0&#xA;\end{array}}\right]r&#xA;$$"></p>
      <p><span class="eqn_num">(9)</span><img class="display_eqn" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_eq90810.png" alt="$$&#xA;{\bf y} = \left[{\begin{array}{cc}&#xA;  C &amp; 0&#xA;\end{array}}\right]&#xA;\left[{\begin{array}{c}&#xA;  {\bf x} \\ {\bf e}&#xA;\end{array}}\right] +&#xA;\left[{\begin{array}{c}&#xA;  0&#xA;\end{array}}\right]r&#xA;$$"></p>
      <p>The closed-loop system described above can be implemented in MATLAB by adding the following commands to the end of your m-file.
         After running the m-file the step response shown will be generated.
      </p><pre class="codeinput">Ace = [(A-B*K) (B*K);
       zeros(size(A)) (A-L*C)];
Bce = [B*Nbar;
       zeros(size(B))];
Cce = [Cc zeros(size(Cc))];
Dce = [0;0];

states = {<span class="string">'x'</span> <span class="string">'x_dot'</span> <span class="string">'phi'</span> <span class="string">'phi_dot'</span> <span class="string">'e1'</span> <span class="string">'e2'</span> <span class="string">'e3'</span> <span class="string">'e4'</span>};
inputs = {<span class="string">'r'</span>};
outputs = {<span class="string">'x'</span>; <span class="string">'phi'</span>};

sys_est_cl = ss(Ace,Bce,Cce,Dce,<span class="string">'statename'</span>,states,<span class="string">'inputname'</span>,inputs,<span class="string">'outputname'</span>,outputs);

t = 0:0.01:5;
r = 0.2*ones(size(t));
[y,t,x]=lsim(sys_est_cl,r,t);
[AX,H1,H2] = plotyy(t,y(:,1),t,y(:,2),<span class="string">'plot'</span>);
set(get(AX(1),<span class="string">'Ylabel'</span>),<span class="string">'String'</span>,<span class="string">'cart position (m)'</span>)
set(get(AX(2),<span class="string">'Ylabel'</span>),<span class="string">'String'</span>,<span class="string">'pendulum angle (radians)'</span>)
title(<span class="string">'Step Response with Observer-Based State-Feedback Control'</span>)
</pre><img class="figure"vspace="5" hspace="5" src="Content/InvertedPendulum/Control/StateSpace/html/InvertedPendulum_ControlStateSpace_04.png" alt=""> <p>This response is almost identical to the response achieved when it was assumed that we had full access to the state variables.
         This is because the observer poles are fast, and because the model we assumed for the observer is identical to the model of
         the actual plant (including the same initial conditions). Therefore, all of the design requirements have been met with the
         minimal control effort expended. No further iteration is needed.
      </p>
      <p>This example demonstrates that it is much easier to control multi-input, multi-output systems with the state-space method
         than with the other methods we have presented.
      </p>
      <p class="footer"><br>
         Published with MATLAB&reg; 7.14<br></p>
   </div>
</div>
<!--
##### SOURCE BEGIN #####
%% Inverted Pendulum: State-Space Methods for Controller Design
%
% Key MATLAB commands used in this tutorial are:
% <http://www.mathworks.com/help/toolbox/control/ref/ss.html |ss|> , 
% <http://www.mathworks.com/help/techdoc/ref/eig.html |eig|> , 
% <http://www.mathworks.com/help/toolbox/control/ref/lsim.html |lsim|> ,
% <http://www.mathworks.com/help/toolbox/control/ref/lqr.html |lqr|> ,
% <http://www.mathworks.com/help/toolbox/control/ref/ctrb.html |ctrb|> ,
% <http://www.mathworks.com/help/toolbox/rf/plotyy.html |plotyy|> , 
% <http://www.mathworks.com/help/toolbox/control/ref/obsv.html |obsv|> ,
% <http://www.mathworks.com/help/toolbox/control/ref/place.html |place|>
%
%%
% From the main problem, the dynamic equations of the inverted pendulum
% system in state-space form are the following: 
%
% $$
% \left[{\begin{array}{c}
%   \dot{x} \\ \ddot{x} \\ \dot{\phi} \\ \ddot{\phi}
% \end{array}}\right] =
% \left[{\begin{array}{cccc}
%   0 & 1 & 0 & 0 \\ 
%   0 & -0.1818 & 2.6727 & 0 \\
%   0 & 0 & 0 & 1 \\
%   0 & -0.4545 & 31.1818 & 0
% \end{array}}\right]
% \left[{\begin{array}{c}
%   x \\ \dot{x} \\ \phi \\ \dot{\phi}
% \end{array}}\right] +
% \left[{\begin{array}{c}
%   0 \\ 1.8182 \\ 0 \\ 4.5455
% \end{array}}\right]u
% $$
% 
% $$
% {\bf y} = \left[{\begin{array}{cccc}
%   1 & 0 & 0 & 0 \\
%   0 & 0 & 1 & 0
% \end{array}}\right]
% \left[{\begin{array}{c}
%   x \\ \dot{x} \\ \phi \\ \dot{\phi}
% \end{array}}\right] +
% \left[{\begin{array}{c}
%   0 \\ 0
% \end{array}}\right]u
% $$
% 
% To see how this problem was originally set up and the system equations were derived, consult the 
% < ?example=InvertedPendulum&section=SystemModeling
% Inverted Pendulum: System Modeling> page. For this problem the outputs
% are the cart's displacement ($x$ in meters) and the pendulum angle ($\phi$ in
% radians) where $\phi$ represents the deviation of the pedulum's position
% from equilibrium, that is, $\theta = \pi + \phi$. 
%
%%
% The design criteria for this system for a 0.2-m step in desired cart
% position $x$ are as follows: 
%
% * Settling time for $x$ and $\theta$ of less than 5 seconds
% * Rise time for $x$ of less than 0.5 seconds
% * Pendulum angle $\theta$ never more than 20 degrees (0.35 radians) from
% the vertical
% * Steady-state error of less than 2% for $x$ and $\theta$ 
%
%%
% As you may have noticed if you went through some of the other inverted
% pendulum examples, the design criteria for this example are different. In
% the other examples we were attemping to keep the pendulum vertical in
% response to an impulsive disturbance force applied to the cart. We did
% not attempt to control the cart's position. In this example, we are
% attempting to keep the pendulum vertical while controlling the cart's
% position to move 0.2 meters to the right. A state-space design approach
% is well suited to the control of multiple outputs as we have here. 
%
% This problem can be solved using full-state feedback. The schematic of
% this type of control system is shown below where $\mathbf{K}$ is a matrix of
% control gains. Note that here we feedback all of the system's states,
% rather than using the system's outputs for feedback.
%
% <<Content/InvertedPendulum/Control/StateSpace/figures/statefeedback_pend2.png>>
%
%% Open-loop poles
%
% In this problem, $r$ represents the step command of the cart's position.
% The 4 states represent the position and velocity of the cart and the
% angle and angular velocity of the pendulum.  The output $\mathbf{y}$ contains both
% the position of the cart and the angle of the pendulum.  We want to
% design a controller so that when a step reference is given to the system, 
% the pendulum should be displaced, but eventually return to zero (i.e.
% vertical) and the cart should move to its new commanded position. To view
% the system's open-loop response please refer to the 
% < ?example=InvertedPendulum&section=SystemAnalysis Inverted Pendulum: System Analysis> page.
%
% The first step in designing a full-state feedback controller is to
% determine the open-loop poles of the system. Enter the following lines of
% code into an < ?aux=Extras_Mfile
% m-file>. After execution in the MATLAB command window, the output will
% list the open-loop poles (eigenvalues of $\mathbf{A}$) as shown below.  

M = 0.5;
m = 0.2;
b = 0.1;
I = 0.006;
g = 9.8;
l = 0.3;

p = I*(M+m)+M*m*l^2; %denominator for the A and B matrices

A = [0      1              0           0;
     0 -(I+m*l^2)*b/p  (m^2*g*l^2)/p   0;
     0      0              0           1;
     0 -(m*l*b)/p       m*g*l*(M+m)/p  0];
B = [     0; 
     (I+m*l^2)/p;
          0;
        m*l/p];
C = [1 0 0 0;
     0 0 1 0];
D = [0;
     0];
 
states = {'x' 'x_dot' 'phi' 'phi_dot'};
inputs = {'u'};
outputs = {'x'; 'phi'};

sys_ss = ss(A,B,C,D,'statename',states,'inputname',inputs,'outputname',outputs);

poles = eig(A)

%%
% As you can see, there is one right-half plane pole at 5.5651. This should
% confirm your intuition that the system is unstable in open loop.
%
%% Linear Quadratic Regulation (LQR)
% The next step in the design process is to find the vector of
% state-feedback control gains $\mathbf{K}$ assuming that we have access (i.e. can
% measure) all four of the state variables. This can be accomplished in a 
% number of ways.  If you know the desired closed-loop pole locations, you
% can use the MATLAB commands |place| or |acker|. Another option is to use
% the |lqr| command which returns the optimal controller gain assuming a
% linear plant, quadratic cost function, and reference equal to zero
% (consult your textbook for more details). 
%
% Before we design our controller, we will first verify that the system is
% *controllable*. Satisfaction of this property means that we can
% drive the state of the system anywhere we like in finite time (under the
% physical constraints of the system). For the system to be completely state
% controllable, the controllability matrix must have rank $n$ where the rank
% of a matrix is the number of independent rows (or columns). The
% controllability matrix of the system takes the form shown below. The
% number $n$ corresponds to the number of state variables of the system.
% Adding additional terms to the controllability matrix with higher powers
% of the matrix $\mathbf{A}$ will not increase the rank of the controllability matrix
% since these additional terms will just be linear combinations of the
% earlier terms.     
%
% $$ \mathcal{C} = [A|AB|A^2B|\cdots|A^{n-1}B] $$
%
% Since our controllability matrix is 4x4, the rank of the matrix must be
% 4. We will use the MATLAB command |ctrb| to generate the controllability
% matrix and the MATLAB command |rank| to test the rank of the matrix.
% Adding the following additional commands to your m-file and running in
% the MATLAB command window will produce the following output.  

co = ctrb(sys_ss);
controllability = rank(co)

%%
% Therefore, we have verified that our system is controllable and thus we
% should  be able to design a controller that achieves the given
% requirements. Specifically, we will use the *linear quadratic regulation*
% method for determining our state-feedback control gain matrix $\mathbf{K}$.
% The MATLAB function |lqr| allows you to choose two parameters, $\mathbf{R}$ and $\mathbf{Q}$, which
% will balance the relative importance of the control effort ($u$) and
% error (deviation from 0), respectively, in 
% the cost function that you are trying to optimize. The simplest case is
% to assume $\mathbf{R}=1$, and  $\mathbf{Q = C'C}$. The cost function corresponding to
% this $\mathbf{R}$ and $\mathbf{Q}$ places equal importance on the control and the state
% variables which are outputs (the pendulum's angle and the cart's
% position). Essentially, the lqr method allows for the control of both outputs.  In
% this case, it is pretty easy  to do.  The controller can be tuned by
% changing the nonzero elements in the $\mathbf{Q}$ matrix to achieve a desirable
% response. To observe the structure of $\mathbf{Q}$, enter the following into the
% MATLAB command window to see the output given below.  

Q = C'*C

%%
% The element in the (1,1) position of $\mathbf{Q}$ represents the weight on the
% cart's position and the element in the (3,3) position represents the
% weight on the pendulum's angle.  The input weighting $\mathbf{R}$ will remain at
% 1. Ultimately what matters is the relative value of $\mathbf{Q}$ and $\mathbf{R}$, not
% their absolute values. Now that we know how to interpret the $\mathbf{Q}$ matrix,
% we can experiment to find the $\mathbf{K}$ matrix that will give us a "good"
% controller.  We will go ahead and find the $\mathbf{K}$ matrix and plot the
% response all in one step so that changes can be made in the control and
% seen automatically in the response. Add the following commands to the end
% of your m-file and run in the MATLAB command window to get the following
% value for $\mathbf{K}$ and the response plot shown below.  

Q = C'*C;
R = 1;
K = lqr(A,B,Q,R)

Ac = [(A-B*K)];
Bc = [B];
Cc = [C];
Dc = [D];

states = {'x' 'x_dot' 'phi' 'phi_dot'};
inputs = {'r'};
outputs = {'x'; 'phi'};

sys_cl = ss(Ac,Bc,Cc,Dc,'statename',states,'inputname',inputs,'outputname',outputs);

t = 0:0.01:5;
r =0.2*ones(size(t));
[y,t,x]=lsim(sys_cl,r,t);
[AX,H1,H2] = plotyy(t,y(:,1),t,y(:,2),'plot');
set(get(AX(1),'Ylabel'),'String','cart position (m)') 
set(get(AX(2),'Ylabel'),'String','pendulum angle (radians)') 
title('Step Response with LQR Control')

%%
% The curve in green represents the pendulum's angle in radians, and the
% curve in blue represents the cart's position in meters. As you can see, 
% this plot is not satisfactory. The pendulum and cart's overshoot appear 
% fine, but their settling times need improvement and the cart's rise time 
% needs to be reduced. As I'm sure you have noticed, the cart's final position is also not near the 
% desired location but has in fact moved in the opposite direction. This error
% will be dealt with in the next section and right now we will focus on the
% settling and rise times. Go back to your m-file and change the $\mathbf{Q}$ matrix
% to see if you can get a better response. You will find that increasing
% the (1,1) and (3,3) elements makes the settling and rise times go down,
% and lowers the angle the pendulum moves. In other words, you are putting
% more weight on the errors at the cost of increased control effort $u$. 
% Modifying your m-file so that the (1,1) element of $\mathbf{Q}$ is 5000 and the
% (3,3) element is 100, will produce the following value of $\mathbf{K}$ and the
% step response shown below.

Q = C'*C;
Q(1,1) = 5000;
Q(3,3) = 100
R = 1;
K = lqr(A,B,Q,R)

Ac = [(A-B*K)];
Bc = [B];
Cc = [C];
Dc = [D];

states = {'x' 'x_dot' 'phi' 'phi_dot'};
inputs = {'r'};
outputs = {'x'; 'phi'};

sys_cl = ss(Ac,Bc,Cc,Dc,'statename',states,'inputname',inputs,'outputname',outputs);

t = 0:0.01:5;
r =0.2*ones(size(t));
[y,t,x]=lsim(sys_cl,r,t);
[AX,H1,H2] = plotyy(t,y(:,1),t,y(:,2),'plot');
set(get(AX(1),'Ylabel'),'String','cart position (m)') 
set(get(AX(2),'Ylabel'),'String','pendulum angle (radians)') 
title('Step Response with LQR Control')

%%
% You may have noted that if you increased the values of the elements of
% $\mathbf{Q}$ even higher, you could improve the response even more. The reason
% this weighting was chosen was because it just satisfies the transient design
% requirements. Increasing the magnitude of $\mathbf{Q}$ more would make the
% tracking error smaller, but would require greater control force $u$. More
% control effort generally corresponds to greater cost (more energy, larger
% actuator, etc.).
%
%% Adding precompensation
% The controller we have designed so far meets our transient requirements,
% but now we must address the steady-state error. In contrast to the
% other design methods, where we feedback the output and compare it to the 
% reference input to compute an error, with a full-state feedback 
% controller we are feeding back all of the states. We need to compute what 
% the steady-state value of the states should be, multiply that by the 
% chosen gain $\mathbf{K}$, and use a new value as our "reference" for computing the 
% input. This can be done by adding a constant gain $\bar{N}$ after the 
% reference. The schematic below shows this relationship:
%
% <<Content/InvertedPendulum/Control/StateSpace/figures/statefeedback_w_pre_pend.png>>
%
% We can find this $\bar{N}$ factor by employing the used-defined function < ?aux=Extras_rscale
% rscale.m> as shown below. The $\mathbf{C}$ matrix is modified to reflect the fact
% that the reference is a command only on cart position.

Cn = [1 0 0 0]; 
sys_ss = ss(A,B,Cn,0);
Nbar = rscale(sys_ss,K)

%%
% Note that the function |rscale.m| is not a standard function in MATLAB.
% You will have to download it <Content/InvertedPendulum/Control/StateSpace/rscale.m here> and place it 
% in your current directory. More information can be found here, < ?aux=Extras_rscale
% Extras: rscale.m>. Now you can plot the step response by adding the above 
% and following lines of code to your m-file and re-running at the command line.   

sys_cl = ss(Ac,Bc*Nbar,Cc,Dc,'statename',states,'inputname',inputs,'outputname',outputs);

t = 0:0.01:5;
r =0.2*ones(size(t));
[y,t,x]=lsim(sys_cl,r,t);
[AX,H1,H2] = plotyy(t,y(:,1),t,y(:,2),'plot');
set(get(AX(1),'Ylabel'),'String','cart position (m)') 
set(get(AX(2),'Ylabel'),'String','pendulum angle (radians)') 
title('Step Response with Precompensation and LQR Control')

%%
% Now, the steady-state error is within our limits, the rise and settle
% times are met, and the pendulum's overshoot is within range of the design
% criteria.
%
% Note that the precompensator $\bar{N}$ employed above is calculated based on
% the model of the plant and further that the precompensator is located
% outside of the feedback loop. Therefore, if there are errors in the model
% (or unknown disturbances) the precompensator will not correct for them
% and there will be steady-state error. You may recall that the addition of
% integral control may also be used to eliminate steady-state error, even
% in the presence of model uncertainty and step disturbances. For an example of how
% to implement integral control in the state space setting, see the
% < ?example=MotorPosition&section=ControlStateSpace
% Motor Position: State-Space Methods> example. The tradeoff with using
% integral control is that the error must first develop before it can be
% corrected for, therefore, the system may be slow to respond. The
% precompensator on the other hand is able to anticipitate the steady-state
% offset using knowledge of the plant model. A useful technique is to
% combine the precompensator with integral control to leverage the
% advantages of each approach. 

%% Observer-based control
% The response achieved above is good, but was based on the assumption of
% full-state feedback, which is not necessarily valid. To address the
% situation where not all state variables are measured, a state estimator
% must be designed. A schematic of state-feedback control with a full-state
% estimator is shown below, without the precompensator $\bar{N}$.
%
% <<Content/InvertedPendulum/Control/StateSpace/figures/observer_statefeedback_pend.png>>
%
% Before we design our estimator, we will first verify that our system is
% *observable*. The property of observability determines whether or not
% based on the measured outputs of the system we can estimate the state
% of the system. Similar to the process for verifying controllability, a
% system is observable if its observability matrix is full rank. The
% observability matrix is defined as follows.
%
% $$ \mathcal{O} =\left[\begin{array}{c} C \\ CA \\ CA^2 \\ \vdots \\ CA^{n-1}
% \end{array} \right] $$
%
% We can employ the MATLAB command |obsv| to contruct the observability matrix
% and the |rank| command to check its rank as shown below.

ob = obsv(sys_ss);
observability = rank(ob)

%%
% Since the observability matrix is 8x4 and has rank 4, it is full rank and
% our system is observable. The observability matrix in this case is not
% square since our system has two outputs. Note that if we could only
% measure the pendulum angle output, we would not be able to estimate the
% full state of the system. This can be verified by the fact that 
% |obsv(A,C(2,:))| produces an observability matrix that is not full rank.
%
% Since we know that we can estimate our system state, we will now describe
% the process for designing a state estimator. 
% Based on the above diagram, the dynamics of the state estimate are
% described by the following equation.
%
% $$ \dot{\hat{{\bf x}}} = A{\hat{\bf x}} + Bu + L({\bf y} - {\hat{\bf y}}) $$
%
% The spirit of this equation is similar to that of closed-loop control in
% that last term is a correction based on feedback. Specifically, 
% the last term corrects the state estimate based on the difference between
% the actual output $y$ and the estimated output $\hat{y}$. Now let's look at
% the dynamics of the error in the state estimate.
%
% $$ \dot{{\bf e}} = \dot{{\bf x}} - \dot{\hat{{\bf x}}} = 
%    (A{\bf x} + Bu) - (A{\hat{\bf x}} + Bu + L(C{\bf x} - C{\hat{\bf x}})) $$
%
% Therefore, the state estimate error dynamics are described by 
%
% $$ \dot{{\bf e}} = (A-LC){\bf e} $$
%
% and the error will approach zero ($\hat{x}$ will approach $x$) if the
% matrix $\mathbf{A-LC}$ is stable (has negative eigenvalues). As is with the case
% for control, the speed of convergence depends on the poles of the
% estimator (eigenvalues of $\mathbf{A-LC}$). Since we plan to use the state
% estimate as the input to our controller, we would like the state estimate
% to converge faster than is desired from our overall closed-loop system.
% That is, we would like the observer poles to be faster than the
% controller poles. A common guideline is to make the estimator poles 4-10
% times faster than the slowest controller pole. Making the estimator poles
% too fast can be problematic if the measurement is corrupted by noise or
% there are errors in the sensor measurement in general. 
%
% Based on this logic, we must first find the controller poles. To do this,
% copy the following code to the end of your m-file.  If you employed the
% updated $\mathbf{Q}$ matrix, you should see the following poles in the MATLAB
% command window.

poles = eig(Ac)

%%
% The slowest poles have real part equal to -4.7592, therefore, we will place
% our estimator poles at -40. Since the closed-loop estimator dynamics are
% determined by a matrix ($\mathbf{A-LC}$) that has a similar form to the matrix
% that determines the dynamics of the state-feedback system ($\mathbf{A-BK}$), we can
% use the same commands for finding the estimator gain $\mathbf{L}$ as we can for
% finding the state-feedback gain $\mathbf{K}$. Specifically, since taking the
% transpose of $\mathbf{A-LC}$ leaves the eigenvalues unchanged and produces a
% result $\mathbf{A'-C'L'}$ that exactly matches the form of $\mathbf{A-BK}$, we can use the
% |acker| or |place| commands. Recalling that the |place| command cannot
% place poles of multiplicity greater than one, we will place 
% the observer poles as follows. Add the following commands to your m-file
% to calculate the $\mathbf{L}$ matrix and generate the output shown below.

P = [-40 -41 -42 -43];
L = place(A',C',P)'

%%
% We are using both outputs (the angle of the pendulum and the position of
% the cart) to design the observer. 
%
% Now we will combine our state-feedback controller from before with our
% state estimator to get the full compensator. The resulting closed-loop
% system is described by the following matrix equations.
%
% $$
% \left[{\begin{array}{c}
%   \dot{{\bf x}} \\ \dot{\bf{e}}
% \end{array}}\right] =
% \left[{\begin{array}{cc}
%   A-BK & BK \\ 
%   0 & A-LC 
% \end{array}}\right]
% \left[{\begin{array}{c}
%   {\bf x} \\ {\bf e}
% \end{array}}\right] +
% \left[{\begin{array}{c}
%   B \bar{N} \\ 0 
% \end{array}}\right]r
% $$
% 
% $$
% {\bf y} = \left[{\begin{array}{cc}
%   C & 0 
% \end{array}}\right]
% \left[{\begin{array}{c}
%   {\bf x} \\ {\bf e}
% \end{array}}\right] +
% \left[{\begin{array}{c}
%   0 
% \end{array}}\right]r
% $$
%
% The closed-loop system described above can be implemented in MATLAB by
% adding the following commands to the end of your m-file. After running
% the m-file the step response shown will be generated. 
%
%%

Ace = [(A-B*K) (B*K);
       zeros(size(A)) (A-L*C)];
Bce = [B*Nbar;
       zeros(size(B))];
Cce = [Cc zeros(size(Cc))];
Dce = [0;0];

states = {'x' 'x_dot' 'phi' 'phi_dot' 'e1' 'e2' 'e3' 'e4'};
inputs = {'r'};
outputs = {'x'; 'phi'};

sys_est_cl = ss(Ace,Bce,Cce,Dce,'statename',states,'inputname',inputs,'outputname',outputs);

t = 0:0.01:5;
r = 0.2*ones(size(t));
[y,t,x]=lsim(sys_est_cl,r,t);
[AX,H1,H2] = plotyy(t,y(:,1),t,y(:,2),'plot');
set(get(AX(1),'Ylabel'),'String','cart position (m)') 
set(get(AX(2),'Ylabel'),'String','pendulum angle (radians)') 
title('Step Response with Observer-Based State-Feedback Control')

%%
% This response is almost identical to the response achieved when it was
% assumed that we had full access to the state variables. This is because
% the observer poles are fast, and because the model we assumed for the
% observer is identical to the model of the actual plant (including the
% same initial conditions). Therefore, all of 
% the design requirements have been met with the minimal control
% effort expended. No further iteration is needed.
%
% This example demonstrates that it is much easier to control multi-input, multi-output
% systems with the state-space method than with the other methods we have presented.

##### SOURCE END #####
-->				</div>
				
				<div id="left">

					<ul class="section">
						<li class="heading" id="System">SYSTEM<img class="section_heading_arrow" src="Images/section_heading_arrow.png"/></li>
						<li class="item" id="SystemModeling"><a href="indexdeb1.html?example=InvertedPendulum&amp;section=SystemModeling">MODELING<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
						<li class="item" id="SystemAnalysis"><a href="indexce00.html?example=InvertedPendulum&amp;section=SystemAnalysis">ANALYSIS<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
					</ul>
					
					<div class="section_break"></div>

					<ul class="section">
						<li class="heading" id="Control">CONTROL<img class="section_heading_arrow" src="Images/section_heading_arrow.png"/></li>
						<li class="item" id="ControlPID"><a href="index9b2d.html?example=InvertedPendulum&amp;section=ControlPID">PID<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
						<li class="item" id="ControlRootLocus"><a href="index2ed1.html?example=InvertedPendulum&amp;section=ControlRootLocus">ROOT&nbsp;LOCUS<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
						<li class="item" id="ControlFrequency"><a href="index64c4.html?example=InvertedPendulum&amp;section=ControlFrequency">FREQUENCY<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
						<li class="item" id="ControlStateSpace"><a href="index96a8.html?example=InvertedPendulum&amp;section=ControlStateSpace">STATE-SPACE<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
						<li class="item" id="ControlDigital"><a href="index5759.html?example=InvertedPendulum&amp;section=ControlDigital">DIGITAL<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
					</ul>
					
					<div class="section_break"></div>

					<ul class="section">
						<li class="heading" id="Simulink">SIMULINK<img class="section_heading_arrow" src="Images/section_heading_arrow.png"/></li>
						<li class="item" id="SimulinkModeling"><a href="indexffaa.html?example=InvertedPendulum&amp;section=SimulinkModeling">MODELING<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
						<li class="item" id="SimulinkControl"><a href="indexd477.html?example=InvertedPendulum&amp;section=SimulinkControl">CONTROL<img class="section_arrow" src="Images/section_arrow.png"/></a></li>
					</ul>
		
				</div>
			
				<div style="clear:both"></div>
				
				<div id="bottombar"><span style="color:#FF5500;font-weight:bold">.</div>
				
			</div>
			
		</div>
	
		<script type="text/javascript" src="script.js"></script>
						
	</body>
	

<!-- Mirrored from ctms.engin.umich.edu/CTMS/index.php?example=InvertedPendulum&section=ControlStateSpace by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 19 Jun 2014 21:12:21 GMT -->
</html>

	StateSpace by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 19 Jun 2014 21:12:21 GMT -->
</html>

	script type="text/javascript" src="script.js"></script>
						
	</body>
	

<!-- Mirrored from ctms.engin.umich.edu/CTMS/index.php?example=InvertedPendulum&section=ControlStateSpace by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 19 Jun 2014 21:12:21 GMT -->
</html>

	StateSpace by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 19 Jun 2014 21:12:21 GMT -->
</html>

	pier/3.x [XR&CO'2014], Thu, 19 Jun 2014 21:12:21 GMT -->
</html>

	StateSpace by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 19 Jun 2014 21:12:21 GMT -->
</html>

	